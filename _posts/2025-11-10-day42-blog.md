---
layout: post
title: "代码训练营Day42-单调栈02"
date: 2025-11-10 10:00:00 -0400
categories: 随笔
---

## Leetcode 42 接雨水（经典问题）
暴力解法属于纵向求解，即求出每一列右边最高的柱子，求出左边最高的柱子，两者取min()，按列计算，最后将雨水相加。O(n^2):会超时。
可以用双指针法优化如上暴力解法，即分别用for循环提前求出每一列的右边最高柱子，左边最高（用数组记录，属于用空间换时间），然后for循环累加计算结果，可优化为O(n)。
注意双指针法需要将之前的最大值与自己比较并取最大值（如果自己是最高的，则选自己，这样之后雨水计算才是正确的，很可能接不到雨水，不然会错误的在此处接到雨水）。
```
        vector<int> maxLeft(height.size(), 0);
        maxLeft[0] = height[0];
        for (int i = 1; i < height.size(); i++){
            maxLeft[i] = max(height[i], maxLeft[i-1]);
        }
```
单调栈思路类似于最大温度问题（单调栈单调递增时），单调栈是横向求解。
当遍历元素大于栈顶元素时进行处理，此时栈顶元素为底，遍历元素为右边第一个大于底的值，栈里第二个值即为底的左边第一个大于它的值（基于单调递增性）。
此时进行计算即可。
当元素相同时最好先pop旧的再push新的，计算比较直接。


## Leetcode 84 柱状图中的最大图形（反复练习）
本题的暴力法：求出每个柱子左右第一个比它矮的柱子的下标，然后通过左右下标和该柱子的高度计算围成的面积。O(n^2):会超时。
本题的双指针优化比较难， 需要理解以下while方法（不能用传统的t--，否则和暴力法没区别，会超时）
```
        // 记录每个柱子 左边第一个小于该柱子的下标
        minLeftIndex[0] = -1; // 注意这里初始化，防止下面while死循环
        for (int i = 1; i < size; i++) {
            int t = i - 1;
            // 这里不是用if，而是不断向左寻找的过程
            while (t >= 0 && heights[t] >= heights[i]) t = minLeftIndex[t];
            minLeftIndex[i] = t;
        }
我用经典例子 heights = [2,1,5,6,2,3] 手把手模拟一下。 
含义：minLeftIndex[i] = i 左侧第一个 < heights[i] 的下标；若不存在，记 -1。   
初始化：minLeftIndex[0] = -1（哨兵，避免死循环）  
  
逐步：
	•	i=1，h=1：t=0；h[0]=2 ≥ 1，跳到 t=minLeftIndex[0]=-1，停；minLeftIndex[1]=-1
	•	i=2，h=5：t=1；h[1]=1 < 5，停；minLeftIndex[2]=1
	•	i=3，h=6：t=2；h[2]=5 < 6，停；minLeftIndex[3]=2
	•	i=4，h=2：t=3；h[3]=6 ≥ 2 → t=minLeftIndex[3]=2；h[2]=5 ≥ 2 → t=minLeftIndex[2]=1；h[1]=1 < 2，停；minLeftIndex[4]=1
	•	i=5，h=3：t=4；h[4]=2 < 3，停；minLeftIndex[5]=4
```
本题适合用单调栈求解，因为求的是第一个比遍历元素小的值，所以是单调递减栈。其余与接雨水类似。  
注意本题需要在数组开头和结尾添加元素0，否则特殊情况无法计算（例如输入数组单调递增或者单调递减，会缺失一边的元素导致无法计算）。





