---
layout: post
title: "代码训练营Day37-动态规划10"
date: 2025-11-03 10:00:00 -0400
categories: 随笔
---

## Leetcode 674 最长连续递增序列
贪心解法最直接,直接count即可。
```
    int findLengthOfLCIS(vector<int>& nums) {
        if (nums.size() == 0) return 0;
        int result = 1; // 连续子序列最少也是1
        int count = 1;
        for (int i = 1; i < nums.size(); i++) {
            if (nums[i] > nums[i - 1]) { // 连续记录
                count++;
            } else { // 不连续，count从头开始
                count = 1;
            }
            if (count > result) result = count;
        }
        return result;
    }
```
dp更有模版性：
dp[i]：以下标i为结尾的连续递增的子序列长度为dp[i]。
递推公式：dp[i] = dp[i - 1] + 1。
初始化：全为1。
遍历顺序：从左向右。

## Leetcode 300 最长递增子序列(反复练习)
dp[i]表示i之前包括i的以nums[i]结尾的最长递增子序列的长度.
递推公式：if (nums[i] > nums[j]) dp[i] = max(dp[i], dp[j] + 1);
初始化：全为1。
遍历顺序：从左向右，外层为i，内层为j。

## Leetcode 718 最长重复子数组（反复练习）
纯暴力解法：纯最朴素暴力（O(nmL)，L 为连续相等段长度）
对每个起点对 (i, j) 往后比到底，取最长。代码最直观，但在最坏情况下会超时。
```
int findLength_brutal(const vector<int>& A, const vector<int>& B) {
    int n = (int)A.size(), m = (int)B.size();
    int ans = 0;
    for (int i = 0; i < n; ++i) {
        for (int j = 0; j < m; ++j) {
            int k = 0;
            while (i + k < n && j + k < m && A[i + k] == B[j + k]) {
                ++k;
            }
            ans = max(ans, k);
        }
    }
    return ans;
}
```
直观的dp解法：
dp[i][j] ：以下标i为结尾的A，和以下标j为结尾的B，最长重复子数组长度为dp[i][j]。
当A[i] 和B[j]相等的时候，dp[i][j] = dp[i - 1][j - 1] + 1;
该定义下第一行和第一列需要分别初始化：将相同的位置设为1，注意此时需要同步更新结果！
遍历顺序：从左向右，先遍历哪个数组都行。
因为是二维数组，每个位置都需要更新result。
```
    int findLength(vector<int>& nums1, vector<int>& nums2) {
        vector<vector<int>> dp (nums1.size(), vector<int>(nums2.size(), 0));
        int result = 0;

        // 要对第一行，第一列经行初始化,更新result！
        for (int i = 0; i < nums1.size(); i++){
            if (nums1[i] == nums2[0]) 
                dp[i][0] = 1;
            result = max(result, dp[i][0]);
        }
        for (int j = 0; j < nums2.size(); j++){
            if (nums1[0] == nums2[j])
                dp[0][j] = 1;
            result = max(result, dp[0][j]);
        }

        for (int i = 1; i < nums1.size(); i++) {
            for (int j = 1; j < nums2.size(); j++) {
                if (nums1[i] == nums2[j]) {
                    dp[i][j] = dp[i - 1][j - 1] + 1;
                }
                if (dp[i][j] > result) result = dp[i][j];
            }
        }
        return result;
    
    }
```
优化解法：
dp[i][j] ：以下标i - 1为结尾的A，和以下标j - 1为结尾的B，最长重复子数组长度为dp[i][j]。
此时需要注意dp的大小为size+1，但好处是不用考虑初始化，因为dp[x][0]/dp[0][x]没有意义，初始为0即可。
```
    int lengthOfLIS(vector<int>& nums) {
        if (nums.size() <= 1) return nums.size();
        vector<int> dp(nums.size(), 1);
        int result = 0;
        for (int i = 1; i < nums.size(); i++) {
            for (int j = 0; j < i; j++) {
                if (nums[i] > nums[j]) dp[i] = max(dp[i], dp[j] + 1);
            }
            if (dp[i] > result) result = dp[i]; // 取长的子序列
        }
        return result;
    }
```
Time: O(n^2).








