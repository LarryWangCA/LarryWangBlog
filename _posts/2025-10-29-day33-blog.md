---
layout: post
title: "代码训练营Day33-动态规划06"
date: 2025-10-29 10:00:00 -0400
categories: 随笔
---

## Leetcode 322 零钱兑换(反复练习)
dp[j]：凑足总额为j所需钱币的最少个数为dp[j]
凑足总额为j - coins[i]的最少个数为dp[j - coins[i]]，那么只需要加上一个钱币coins[i]即dp[j - coins[i]] + 1就是dp[j]（考虑coins[i]）
所以dp[j] 要取所有 dp[j - coins[i]] + 1 中最小的。
递推公式：dp[j] = min(dp[j - coins[i]] + 1, dp[j]);
初始化：dp[0]=0;dp数组初始化：因为本题递推是min相关，所以初始化成INT_MAX;
遍历顺序：本题求钱币最小个数，那么钱币有顺序和没有顺序都可以，都不影响钱币的最小个数。

## Leetcode 279 完全平方数
dp[j]：和为j的完全平方数的最少数量为dp[j]。    
递推公式：dp[j] = min(dp[j - i * i] + 1, dp[j])。   
初始化：dp[0]=0 //本题输入从1开始，理论上0*0=0，但是这是为了后面的递推，否则dp[1]=2就错误了
遍历顺序：属于完全背包，既不是排列也不是组合，而是求最小数（与上题相同），所以for循环内外无所谓。

## Leetcode 139 单词拆分（反复练习）
本质上更像是一个暴力搜索的问题，字符串拆成两段，前半部分如果在字典中，后半部分也在字典中即为true。
但是这题拆分方式有很多种，所以我们需要for循环嵌套去考虑所有情况。
也可以用dp的思路,完全背包求排列
dp[j]:bool类型，长度为j的字符串可以被拆分成一个或者多个在字典中的单词。
递推公式：dp[j] == dp[i] (i<j) && substr[s,j-i]为true；
初始化：dp[0]=true;//空集合为true，否则之后全为false。
遍历顺序：先背包，后物品。本题字符串对于顺序有要求，只能是排列的写法。

## 多重背包(简单了解即可)
简单了解即可，即每个物品的数量>=1,但又不是完全背包那样无限个。
本质上还是一个01背包，我们可以将数量大于1的同一个物品添加多次，转化为01背包。
```
for (int i = 0; i < n; i++) {
    while (nums[i] > 1) { // 物品数量不是一的，都展开
        weight.push_back(weight[i]);
        value.push_back(value[i]);
        nums[i]--;
    }
}
```


