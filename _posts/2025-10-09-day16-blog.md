---
layout: post
title: "代码训练营Day14-二叉树06"
date: 2025-10-09 10:00:00 -0400
categories: 随笔
---

## Leetcode 530 二叉搜索树的最小绝对差
用中序遍历数组法属于送分题，可以用双指针法(空间更优)在递归时直接判断。
```
class Solution {
private:
int result = INT_MAX;
TreeNode* pre = NULL;
void traversal(TreeNode* cur) {
    if (cur == NULL) return;
    traversal(cur->left);   // 左
    if (pre != NULL){       // 中
        result = min(result, cur->val - pre->val);
    }
    pre = cur; // 记录前一个
    traversal(cur->right);  // 右
}
public:
    int getMinimumDifference(TreeNode* root) {
        traversal(root);
        return result;
    }
};
```

## Leetcode 501 二叉搜索树中的众数（反复练习）
注意众数可能不止一个。
本题暴力法和之前相同，遍历时各节点出现频率存为unordered_map,然后将map排序后保存结果。
双指针法传统上为遍历两次，一次最大频率，一次最大频率对应的频率，但可以优化为只遍历一次。  
即如果之后单个元素的频率大于之前的最大频率，清空结果集即可(同时保证了同一个元素不会被重复添加)。

## LeetCode 236 二叉树的最近公共祖先（反复练习）
求最小公共祖先，需要从底向上遍历，那么二叉树，只能通过后序遍历（即：回溯）实现从底向上的遍历方式。

在回溯的过程中，必然要遍历整棵二叉树，即使已经找到结果了，依然要把其他节点遍历完，因为要使用递归函数的返回值（也就是代码中的left和right）做逻辑判断。

要理解如果返回值left为空，right不为空为什么要返回right，为什么可以用返回right传给上一层结果。





