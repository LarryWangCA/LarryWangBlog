---
layout: post
title: "代码训练营Day12-二叉树02"
date: 2025-10-02 10:00:00 -0400
categories: 随笔
tags: [tree]
---

## Leetcode 226 翻转二叉树
递归法时前序和后续都比较直接，在中间节点处使用swap交换左和右即可。  
注意swap交换的是指针变量（cur->left），并不是数值(cur->left->val)。

## Leetcode 101 对称二叉树
只能用后序遍历，因为所有遍历中，‘中’的部分是逻辑处理部分，我们必须知道左右子树的情况才能在‘中’进行判断。  
递归的终止条件永远在开始，否则会无限递归下去。  

## Leetcode 559 N叉树的最大深度
题目本身不难，需要注意一下N叉树的定义：  
```
/*
// Definition for a Node.
class Node {
public:
    int val;
    vector<Node*> children;

    Node() {}

    Node(int _val) {
        val = _val;
    }

    Node(int _val, vector<Node*> _children) {
        val = _val;
        children = _children;
    }
};
*/
```
一下是可以构造一个简单的二叉树，根节点的children[0,1,2]分别是node2,3,4.
```
Node* root  = new Node(1, {node2, node3, node4});
```
如果node3有一个孩子，我们需要通过root->children[1]->children[0]来访问该孩子,只能一层一层往下找。




