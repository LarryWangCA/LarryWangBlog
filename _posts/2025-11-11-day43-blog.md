---
layout: post
title: "代码训练营Day43-图论01"
date: 2025-11-11 10:00:00 -0400
categories: 随笔
---

# C++ Tips
将类中的成员变量理解为引用，共享了内存，即在原地址上进行修改（dfs时需要回溯）。

## ACM模式下输入输出模版（TODO：需要花时间熟悉）
https://programmercarl.com/qita/acm1.html

## 图论理论基础
看网站即可：https://programmercarl.com/kamacoder/%E5%9B%BE%E8%AE%BA%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80.html#%E8%BF%9E%E9%80%9A%E6%80%A7
图主要用邻接矩阵和领接表表示。

## dfs理论基础
对着一个方向搜索，直到撞到南墙了（或找到结果了）再回头。
和之前的dfs在二叉树上的运用非常像，只是这里是应用在图这种数据结构中。
https://programmercarl.com/kamacoder/%E5%9B%BE%E8%AE%BA%E6%B7%B1%E6%90%9C%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80.html#dfs-%E6%90%9C%E7%B4%A2%E8%BF%87%E7%A8%8B
图论中dfs中for循环可以理解为：从 0 出发，邻居全试，递归到底，回溯再试 （即图论中既然从节点0出发，考虑其邻居的每种情况后就是最终结果。）  
```
void dfs(参数) {
    if (终止条件) {
        存放结果;
        return;
    }

    for (选择：本节点所连接的其他节点) {
        处理节点;
        dfs(图，选择的节点); // 递归
        回溯，撤销处理结果
    }
}
```


## Leetcode 797 All Paths From Source to Target
图论中基础dfs问题，但是也要搞清楚。
graph的定义：graph = [[1,2],[3],[3],[]]//即节点0连接这1和2.etc
dfs前记得将节点0提前加入。

## bfs理论基础
一圈一圈的像同心圆一样从内向外搜索，用队列实现（每次都是同一方向，用栈的话会顺时针逆时针交替）。
和之前的bfs在二叉树上的运用非常像，只是这里是应用在图这种数据结构中。
需要用一个数组标记已经添加过的元素，防止重复添加。
```
int dir[4][2] = {0, 1, 1, 0, -1, 0, 0, -1}; // 表示四个方向
// grid 是地图，也就是一个二维数组
// visited标记访问过的节点，不要重复访问
// x,y 表示开始搜索节点的下标
void bfs(vector<vector<char>>& grid, vector<vector<bool>>& visited, int x, int y) {
    queue<pair<int, int>> que; // 定义队列
    que.push({x, y}); // 起始节点加入队列
    visited[x][y] = true; // 只要加入队列，立刻标记为访问过的节点
    while(!que.empty()) { // 开始遍历队列里的元素
        pair<int ,int> cur = que.front(); que.pop(); // 从队列取元素
        int curx = cur.first;
        int cury = cur.second; // 当前节点坐标
        for (int i = 0; i < 4; i++) { // 开始想当前节点的四个方向左右上下去遍历
            int nextx = curx + dir[i][0];
            int nexty = cury + dir[i][1]; // 获取周边四个方向的坐标
            if (nextx < 0 || nextx >= grid.size() || nexty < 0 || nexty >= grid[0].size()) continue;  // 坐标越界了，直接跳过
            if (!visited[nextx][nexty]) { // 如果节点没被访问过
                que.push({nextx, nexty});  // 队列添加该节点为下一轮要遍历的节点
                visited[nextx][nexty] = true; // 只要加入队列立刻标记，避免重复访问
            }
        }
    }

}
```



