---
layout: post
title: "个人代码训练营Day63"
date: 2026-02-02 10:00:00 -0400
categories: 随笔
---

# C++ Tips
stack和queue不能像vector一样预设大小。    
this的使用（绝大部分时候不需要）  
	•	普通 class 的非 static 方法互相调用：不需要 this。  
	•	模板派生类调用依赖基类成员：常需要 this->（或 Base<T>::）。  
	•	static 方法：没有 this。  
struct/class 的构造行为完全相同，
class的成员变量会被默认初始化。  
```
更精确地说：创建对象时顺序是这样的（以 class/struct 都一样）：
	1.	先初始化所有成员
初始化来源按优先级：
	•	构造函数的 初始化列表（: a(...), b(...)）
	•	否则用成员的 默认成员初始化器（比如 int i = -1;）
	•	否则再走 默认初始化/默认构造（比如 vector 默认空；内置类型在某些情况下可能是未定义值）
	2.	然后才执行构造函数的函数体（{ ... } 里面的代码）
```

## Leetcode 1910. Remove All Occurrences of a Substring (反复练习)
使用for循环，每次将char放入结果，当结果>=目标的长度，用substr比较（判断是否弹出）
最坏时间复杂度是 O(n * m)（n = s.size(), m = part.size()）。

## Leetcode 203. Remove Linked List Elements
简单题，dummy可以不连接head，最后要加上nullptr终止。  

## Leetcode 238. Product of Array Except Self (反复练习)
需要运用前缀和后缀的思想，一次从前往后，一次从后往前。
注意第二次更新结果的时候是相乘！或者前缀后缀分别存储，最后相乘！

## Leetcode 346. Moving Average from Data Stream （反复练习）
用一个queue实现滑动窗口就行，超过大小之后就弹出最先push的。

## Leetcode 1487. Making File Names Unique(反复练习)
用一个unordered_map保存string和之后的index大小，注意更改后的名称可能依然存在，需要用while循环判断直到不存在。
可以更新原名称的k使得之后查找更快(optional)，将新名称放进map中（必须）。
Time: O(N)

## Leetcode 2208. Minimum Operations to Halve Array Sum（反复练习）
典型的大顶堆应用（默认priority_queue）,注意类型是double即可。  

## Leetcode 1586. Binary Search Tree Iterator II（反复练习）
直接用dfs中序遍历之后返回结果即可，构造：O(n) 时间 + O(n) 空间。

所以优化版做的是（了解即可）：  
	1.	树的部分：用一个栈 st 做“懒中序遍历”  
只在你真的调用 next() 需要新元素时，才从树里拿下一个中序元素。  
	2.	历史部分：用 history 记录“已经产生过的 next() 结果”  
这样你调用 prev() 就只是 idx--，从 history 里取值，O(1)。  





