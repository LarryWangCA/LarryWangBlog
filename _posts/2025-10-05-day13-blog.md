## Leetcode 222 完全二叉树的节点个数
递归后序遍历即可。


## Leetcode 110 平衡二叉树
本质上是利用后序遍历求高度，只是额外加上了左和右的判断而已，以下是经典求高度的方法。
```
int getHeight(TreeNode* root) {
    if (root == nullptr) return 0;
    int left = getHeight(root->left);
    int right = getHeight(root->right);
    return 1 + max(left, right);
}

```
以下是本题解法，前两个if剪枝不能取消，取消了会让最后的逻辑变得混乱，因为设为-1不应该带入具体高度的计算，剪枝也可以优化性能。
```
class Solution {
public:
    // 返回以该节点为根节点的二叉树的高度，如果不是平衡二叉树了则返回-1
    int getHeight(TreeNode* node) {
        if (node == NULL) {
            return 0;
        }
        int leftHeight = getHeight(node->left);
        if (leftHeight == -1) return -1;
        int rightHeight = getHeight(node->right);
        if (rightHeight == -1) return -1;
        return abs(leftHeight - rightHeight) > 1 ? -1 : 1 + max(leftHeight, rightHeight);
    }
    bool isBalanced(TreeNode* root) {
        return getHeight(root) == -1 ? false : true;
    }
};
```
