---
layout: post
title: "代码训练营Day13-二叉树03"
date: 2025-10-05 10:00:00 -0400
categories: 随笔
---

## Leetcode 222 完全二叉树的节点个数
递归后序遍历即可，但是这种解法与普通二叉树没有区别，没有利用完全二叉树的性质，时间复杂度O(N)【相当于每个节点都遍历了一遍】；空间复杂度为O(logN)/O(h) (递归中栈占用的空间)。
我们只需找到满二叉树，然后用pow(2, depth) -1 或者位运算(2<<depth)-1即可快速计算二叉树的节点数量，无需遍历所有节点。
如何判断满二叉树？因为题目说了是完全二叉树，所以我们只需要一直向左递归，再一直向右递归，左侧深度等于右侧深度即可。


## Leetcode 110 平衡二叉树
本质上是利用后序遍历求高度，只是额外加上了左和右的判断而已，以下是经典求高度的方法。
```
int getHeight(TreeNode* root) {
    if (root == nullptr) return 0;
    int left = getHeight(root->left);
    int right = getHeight(root->right);
    return 1 + max(left, right);
}

```
以下是本题解法，前两个if剪枝不能取消，取消了会让最后的逻辑变得混乱，因为设为-1不应该带入具体高度的计算，剪枝也可以优化性能。
```
class Solution {
public:
    // 返回以该节点为根节点的二叉树的高度，如果不是平衡二叉树了则返回-1
    int getHeight(TreeNode* node) {
        if (node == NULL) {
            return 0;
        }
        int leftHeight = getHeight(node->left);
        if (leftHeight == -1) return -1;
        int rightHeight = getHeight(node->right);
        if (rightHeight == -1) return -1;
        return abs(leftHeight - rightHeight) > 1 ? -1 : 1 + max(leftHeight, rightHeight);
    }
    bool isBalanced(TreeNode* root) {
        return getHeight(root) == -1 ? false : true;
    }
};
```

## Leetcode 257 二叉树的所有路径(好题，需要反复练习)
此题中需要用到‘显式回溯’.pop_back()，与之前的前序遍历的‘隐式回溯’不同，隐式回溯我们只是探究遍历的过程，回溯的过程由程序流自动完成。
而本题我们需要保存每一条路径，我们必须手动回溯，不然结果中会包含之前路径中的节点，这也是遍历问题与路径问题的区别。
本题在叶子节点处就进行终止条件的判断比较简单，逻辑清楚，也能减少多余的递归调用。
遍历类问题在空节点处直接返回即可，但是根到路径类问题需要在叶子节点处收集结果。 
c++中，to_string(x)可以将整数/浮点数转换为字符串。

## Leetcode 404 左子叶之和(好题，需要反复练习)
题目重点，我们需要判断的是该节点是否有左叶子（即有左孩子且左孩子为叶子）,实际为在叶子的上一层进行判断，而不是叶子本身。
个人觉得前序遍历比较直接且好理解，需要注意前序遍历时函数为void，因为并不是递归的每一层都有返回值。
```
    void preOrder(TreeNode* cur){
        if (!cur) return;
        //判断该节点是否有左叶子(有左孩子且左孩子为叶子)
        if (cur->left && !cur->left->left && !cur->left->right){
            sum += cur->left->val;
        }
        preOrder(cur->left);
        preOrder(cur->right);
    }
```
代码随想录官方用的是后序遍历，好处是可以在原函数上直接操作，无需额外的全局变量。  
后序遍历在遍历中表示左右中，但是对于结果遍历来说，表示先计算左右子树的结果，再计算当前层。    
左叶子永远只会在递归的左子树出现，2放在1之后逻辑直接，放在3后面也行，但是逻辑拖沓，相当于左右子树均递归完之后再判断。
```
int sumOfLeftLeaves(TreeNode* root) {
    if (root == NULL) return 0;
    if (root->left == NULL && root->right== NULL) return 0;

    int leftValue = sumOfLeftLeaves(root->left);    // 1️⃣ 递归左子树
    if (root->left && !root->left->left && !root->left->right) { // 2️⃣ 判断左叶子
        leftValue = root->left->val;
    }
    int rightValue = sumOfLeftLeaves(root->right);  // 3️⃣ 递归右子树

    int sum = leftValue + rightValue;               // 4️⃣ 汇总结果
    return sum;
}
```












