

## Leetcode 222 完全二叉树的节点个数
递归后序遍历即可。


## Leetcode 110 平衡二叉树
本质上是利用后序遍历求高度，只是额外加上了左和右的判断而已，以下是经典求高度的方法。
```
int getHeight(TreeNode* root) {
    if (root == nullptr) return 0;
    int left = getHeight(root->left);
    int right = getHeight(root->right);
    return 1 + max(left, right);
}

```
以下是本题解法，前两个if剪枝不能取消，取消了会让最后的逻辑变得混乱，因为设为-1不应该带入具体高度的计算，剪枝也可以优化性能。
```
class Solution {
public:
    // 返回以该节点为根节点的二叉树的高度，如果不是平衡二叉树了则返回-1
    int getHeight(TreeNode* node) {
        if (node == NULL) {
            return 0;
        }
        int leftHeight = getHeight(node->left);
        if (leftHeight == -1) return -1;
        int rightHeight = getHeight(node->right);
        if (rightHeight == -1) return -1;
        return abs(leftHeight - rightHeight) > 1 ? -1 : 1 + max(leftHeight, rightHeight);
    }
    bool isBalanced(TreeNode* root) {
        return getHeight(root) == -1 ? false : true;
    }
};
```

## Leetcode 257 二叉树的所有路径(好题，需要反复练习)
此题中需要用到‘显式回溯’，与之前的前序遍历的‘隐式回溯’不同，隐式回溯我们只是探究遍历的过程，回溯的过程由程序流自动完成。
而本题我们需要保存每一条路径，我们必须手动回溯，不然结果中会包含之前路径中的节点，这也是遍历问题与路径问题的区别。
本题在叶子节点处就进行终止条件的判断比较简单，逻辑清楚，也能减少多余的递归调用。
遍历类问题在空节点处直接返回即可，但是根到路径类问题需要在叶子节点处收集结果。 
c++中，to_string(x)可以将整数/浮点数转换为字符串。












