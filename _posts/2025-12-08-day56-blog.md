---
layout: post
title: "个人代码训练营Day56-Heap day01"
date: 2025-12-08 10:00:00 -0400
categories: 随笔
---

# C++ Heap数据结构
priority_queue 就是 C++ 的堆实现, 本质上是一个完全二叉树。  
priority_queue<int> maxHeap;   // 默认：最大堆  
priority_queue<int, vector<int>, greater<int>> minHeap; // 最小堆  
最大堆 → top 最大 → pop 最大  
最小堆 → top 最小 → pop 最小  
在进行top和pop时一定要进行非空.empty()判断！  
.top():返回堆顶，O(1).  
.pop():删除堆顶，需要重构堆, O(logN).//取决于完全二叉树的高度，h=log2(N)  
.push(num):插入新节点，需要重构堆，O(logN).

## Leetcode 215. Kth Largest Element in an Array (反复练习)
直接解法使用sort，Time complexity: O(n⋅logn), Space Complexity: O(logn).  
看到求k个最大、最小值应该想到使用heap，直接使用最小堆即可。  
思路： 维护一个 大小为 k 的最小堆  
	•	堆中永远存的是目前“最大的 k 个数字”  
	•	堆顶的最小值，就是这 k 个数中最小的 → 即第 k 大  
Time complexity: O(n⋅logk), Space Complexity: O(logk). 

## Leetcode 502. IPO （反复练习）
暴力解法for循环嵌套会超时。
本题需要使用贪心方法，每一步都要从当前能做的项目中（caiptal是门槛，不是成本！），挑 profit 最大的。  
原因：
	•	profit ≥ 0（不会亏钱）  
	•	做项目只会让资本 W 增加  
	•	可做项目的集合 monotonically expands（单调扩张）  
	•	因此逐步挑最大 profit 是正确贪心  
⭐ 将项目按 capital 升序排序，目的不是选项目，而是：  
让我们用一个指针 ptr，顺序把“刚刚变得可做”的项目加入堆中。  
⭐ 最大堆 priority_queue
堆中按 profit 排序，profit 最大的项目在堆顶。  
Time complexity: O(nlogn). Space complexity: O(n)







