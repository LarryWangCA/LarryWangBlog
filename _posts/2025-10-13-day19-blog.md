---
layout: post
title: "代码训练营Day19-回溯01"
date: 2025-10-13 10:00:00 -0400
categories: 随笔
---

理论基础（树形结构），看代码随想录官网的示意图和模版。
本质上是一种纯暴力的解法。

## Leetcode 77 组合
套用模版即可，搞清楚以下内容。
🔁 总结：for 循环的意义
动作	含义
for (int i = startIndex; i <= n; i++)	当前层依次选择每一个可能的数
path.push_back(i)	选择一个数
backtracking(n, k, i + 1)	递归进入下一层，从下一个数开始选
path.pop_back()	回溯，撤销选择，尝试下一个

层1: for(i = 1 → 4)      层2: for(i = startIndex → 4)
-----------------------------------------------------
选1 → [1] ──┬─ i=2 → [1,2] ✅
             ├─ i=3 → [1,3] ✅
             └─ i=4 → [1,4] ✅

选2 → [2] ──┬─ i=3 → [2,3] ✅
             └─ i=4 → [2,4] ✅

选3 → [3] ──└─ i=4 → [3,4] ✅

选4 → [4] （没有更多可选了）

本题可以通过for循环剪枝（即开始的数不能超过某个值，否则无论如何也没有结果）
1-已经选择的元素个数：path.size();
2-所需需要的元素个数为: k - path.size();
3-列表中剩余元素（n-i） >= 所需需要的元素个数（k - path.size()）
4-在集合n中至多要从该起始位置 : i <= n - (k - path.size()) + 1，开始遍历

## Leetcode 216 组合总和 III（反复练习）
注意事项：1）终止条件是通过元素个数判断而不是sum是否为目标，sum是否为目标只是收获结果的判断；
Sum其实可以作为终止条件，查过sum直接终止，等于sum收货结果，只是本题用元素个数更直接，效率更高。
关于剪枝：1）与上题相同，在for循环的循环体里控制；
2）在循环的单层逻辑中，提前判断当前的和是否已经超过了目标，如果超过了就终止当前层并返回上一层。
e.g. 1+2已经大于target，之后的1+3, 1+4 ...肯定都大于target。
最好是先剪枝（直接判断），再来传统的处理逻辑，省的判断变量是否需要回溯，即是值传递（只是本地副本改变，不用回溯），还是引用，全局、成员变量（本体改变，需要回溯）.
```
        for (int i = startIndex; i <= 9-(k-path.size())+1; i++){
            if (currentSum+i > targetSum) return;
            currentSum += i;
            path.push_back(i);
            backtracking(targetSum, currentSum, k, i+1); //需要递归下一层！
            path.pop_back();
            currentSum -= i;//如果是按照值传递的（本地副本），这句话多余 
        }
```
容器/路径（全局）要回溯，标量按值可不回溯；共享就撤销，副本自动好，所以代码可以有如下优化：
```
    for (int i = start; i <= 9 - (k - path.size()) + 1; ++i) {
        if (sum + i > target) break;          // 单调剪枝，前置判断
        path.push_back(i);
        backtracking(target, sum + i, k, i + 1); // sum 按值传递，自动“回溯”
        path.pop_back();                        // 必须回溯 path
    }
```

3）break和return在这里没有区别，因为for循环之后没有别的处理语句。如果有的话return也不会执行，但是break会跳出循环后执行剩余语句。

## Leetcode 17 电话号码的字母组合
本题的递归和终止条件通过输入的数字个数进行判断。一个数字代表一个集合。
第一层在第一个数字中取字母，第二层即为在第二个数字中取字母。






