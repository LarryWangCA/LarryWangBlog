---
layout: post
title: "代码训练营Day35-动态规划08"
date: 2025-10-31 10:00:00 -0400
categories: 随笔
tags: [dp]
---

## Leetcode 121 买卖股票的最佳时机
本题可以直接用贪心算法，取最左最小值，最右最大值即可。
```
    int maxProfit(vector<int>& prices) {
        int low = INT_MAX;
        int result = 0;
        for (int i = 0; i < prices.size(); i++) {
            low = min(low, prices[i]);  // 取最左最小价格
            result = max(result, prices[i] - low); // 直接取最大区间利润
        }
        return result;
    }
```
动态规划的思路比较具有模版性：
dp[i][0] 表示第i天持有股票所得最多现金;dp[i][1] 表示第i天不持有股票所得最多现金。
递推公式：
dp[i][0] = max(dp[i - 1][0], -prices[i]);//注意只能买入一次，第一次买入前现金为0
dp[i][1] = max(dp[i - 1][1], prices[i] + dp[i - 1][0]);
初始化：
dp[0][0] = -prices[0];
dp[0][1] = 0;
其余为0即可。   
遍历顺序：从左往右。
因为只能买卖一次且亏损记为0，卖出的情况一定比买入挣得多。

## Leetcode 122 买卖股票的最佳时机 II
本题也是贪心更简单，有利润卖出即可。
```
    int maxProfit(vector<int>& prices) {
        int res = 0;
        for (int i = 1; i < prices.size(); i++){
            int gap = prices[i] - prices[i-1];
            if (gap > 0)
                res += gap; 
        }
        return res;
    }
```
动态规划的思路比较具有模版性：
dp[i][0] 表示第i天持有股票所得最多现金;dp[i][1] 表示第i天不持有股票所得最多现金。
递推公式：
dp[i][0] = max(dp[i - 1][0], dp[i-1][1]-prices[i]);//注意只能持有一只股票，买入前现金为dp[i-1][1]
dp[i][1] = max(dp[i - 1][1], prices[i] + dp[i - 1][0]);
初始化：
dp[0][0] = -prices[0];
dp[0][1] = 0;
其余为0即可。   
遍历顺序：从左往右。
因为亏损记为0，卖出的情况一定比买入挣得多。

## Leetcode 122 买卖股票的最佳时机 III
和前两题的dp解法类似，可以理解为允许同一天买入卖出，反正收益是0没影响。
和122的区别仅仅是多了两个状态（第二次买入，第二次卖出）。







