---
layout: post
title: "个人代码训练营Day58-位运算day04"
date: 2025-12-17 10:00:00 -0400
categories: 随笔
tags: [bit]
---

## Leetcode 8. String to Integer (atoi) （看思路即可）
本题跳过空格用一个while循环判断即可，用int正负一保存正负号。  
难点在于转换后的结果是否会超出int的范围。
可以存为long long在直接比较（不推荐，因为不是考点）。  
INT_MAX = 2^31-1; INT_MIN = -2^31;  
不能直接写以下语句
```
if (ans * 10 + d > INT_MAX)  // ❌ 可能已经溢出了
```
而是反推（提前判断）
```
ans * 10 + d <= INT_MAX
ans <= (INT_MAX - d) / 10
```
负数同理，符号是最后乘的，只差1.  
```
if (ans > ((long long)INT_MAX + 1 - d) / 10)
    return INT_MIN;
```

## Leetcode 268 Missing Number (注意解法3，基于XOR)
本题很简单，但是有三种解法，但是时间空间复杂度各不相同。  
1）排序法，最直接(Time: O(nlogn); Space:O(1)).  
```
sort(nums.begin(), nums.end());
for (int i = 0; i < n; i++)
    if (nums[i] != i) return i;
return n;
```
2) hash法，使用unordered_set,时间复杂度更好，但是空间复杂度差 (Time: O(n); Space:O(n)).   
```
    int missingNumber(vector<int>& nums) {
        int n = nums.size();

        unordered_set<int> s;
        for (int x : nums) {
            s.insert(x);
        }

        for (int i = 0; i <= n; i++) {
            if (s.count(i) == 0) {
                return i;
            }
        }

        return -1; // 理论上不会走到这里
    }
```
3）使用位运算，基于XOR的性质 （Time: O(n); Space:O(1)） 
XOR 的本质是：成对消失，落单留下。   
```
int missingNumber(vector<int>& nums) {
    int n = nums.size();
    int res = n;
    for (int i = 0; i < n; i++) {
        res ^= i ^ nums[i];
    }
    return res;
}
```

## Leetcode 287. Find the Duplicate Number（了解判圈法）
和上题一样，sort和unordered_set解法都很简单。  
因为本题数组的元素范围恰巧也是1到n（很重要！），可以使用判圈法。  
// Phase 1: 在环里找到一个相遇点（保证在环中）
slow/fast 走不同速度，最终相遇  
// Phase 2: 从起点和相遇点同时走，找到环入口
ptr1 从 nums[0] 出发，ptr2 从相遇点(环内)出发，同速走，相遇点就是入口 = duplicate
```
        // Phase 1: find intersection point in the cycle
        int slow = nums[0];
        int fast = nums[0];
        do {
            slow = nums[slow];          // 走 1 步
            fast = nums[nums[fast]];    // 走 2 步
        } while (slow != fast);

        // Phase 2: find entrance to the cycle
        int ptr1 = nums[0];
        int ptr2 = slow;
        while (ptr1 != ptr2) {
            ptr1 = nums[ptr1];
            ptr2 = nums[ptr2];
        }
        return ptr1; // duplicate number
    }
```




