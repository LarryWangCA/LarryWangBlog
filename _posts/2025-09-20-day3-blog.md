---
layout: post
title: "代码训练营Day3-链表01"
date: 2025-09-20 9:00:00 -0400
categories: 随笔
tags: [linked-list]
---


## Linked list相关知识
```
// 单链表
struct ListNode {
    int val;  // 节点上存储的元素
    ListNode *next;  // 指向下一个节点的指针
    ListNode(int x) : val(x), next(NULL) {}  // 节点的构造函数
};
```
数组适合数据量固定，频繁查询 O(1)，较少增删 O(n)。
链表适合数据量不固定，频繁增删 O(1)，较少查询 O(n)。


ListNode dummy(0);
→ Use this when you need a dummy head that makes code simpler (avoids handling edge cases like empty list). You usually return dummy.next.
dummy 生命周期随函数结束自动结束，不需要你 delete  
ListNode* p = new ListNode(0);
→ Use this when you want your head node itself to be on the heap and part of the final result. You usually return p
 p 这个节点是动态分配的，除非你之后 delete p，否则会泄漏  
👉 In practice, most LeetCode list solutions prefer dummy(0) on the stack and return dummy.next. It’s shorter and avoids worrying about cleaning up the extra dummy node.  
 

What is nullptr?
nullptr is a special keyword in C++11 and later. It represents a null pointer constant. Its meaning: “this pointer does not point to any object/function”. So if a pointer holds nullptr, it is valid, but it points to nothing.

Does it "not exist"?
The pointer exists as a variable in memory. Its value is null, meaning "no address / not pointing to anything".


## Leetcode 203 移除链表元素
Chatgpt提供的ListNode dummy(0); ListNode *p = &dummy写法更好
记得最后加上p->next = nullptr来结束链表，返回dummy.next

## Leetcode 707 设计链表 (需要重做重新复习！)
在链表中插入新节点的顺序非常重要！
一定是在当前想插入节点后，与其一起指向同一个next，之后再将之前的节点指向新节点
出于安全的考虑（防止内存泄漏），应该将需要删除的节点在内存中释放掉
        LinkedNode* tmp = cur->next;
        delete tmp;
        //delete命令指示释放了tmp指针原本所指的那部分内存，
        //被delete后的指针tmp的值（地址）并非就是NULL，而是随机值。也就是被delete后，
        //如果不再加上一句tmp=nullptr,tmp会成为乱指的野指针
        //如果之后的程序不小心使用了tmp，会指向难以预想的内存空间
        tmp=nullptr;
        
1. dummyHead 的写法

指针方式（常见写法）：

ListNode* dummyHead;
MyLinkedList() {
    dummyHead = new ListNode(0);
}


dummyHead 是指针，必须用 new 在堆上分配。

缺点：需要在析构函数里 delete，否则会内存泄漏。

对象方式（更安全写法）：

ListNode dummyHead;
MyLinkedList() : dummyHead(0), size(0) {}


dummyHead 是对象，跟随 MyLinkedList 生命周期自动释放。

不需要手动 delete，更适合刷题。

2. 构造函数里 dummyHead 的初始化

错误写法：

MyLinkedList() {
    size = 0;
    dummyHead = ListNode(0);  // ❌ 报错：没有默认构造函数
}


成员 dummyHead 在进入 {} 前必须构造。

但 ListNode 只有带参构造，没有默认构造函数 → 编译错误。

正确写法（推荐）：

MyLinkedList() : dummyHead(0), size(0) {}   // ✅ 初始化列表


另一种做法：给 ListNode 增加一个默认构造函数，这样就能用“先构造再赋值”的形式了。

struct ListNode {
    int val;
    ListNode* next;
    ListNode() : val(0), next(nullptr) {}       // 默认构造
    ListNode(int v) : val(v), next(nullptr) {}  // 带参构造
};

3. 为什么 size = 0 可以，而 dummyHead = ListNode(0) 不行？

int size 是 内置类型，没有构造函数，赋值随时都行：

size = 0;   // ✅
size(0);    // ✅


ListNode dummyHead 是 自定义类型，必须先构造。

如果没默认构造，就不能“先构造再赋值”。

只能用初始化列表 dummyHead(0) 直接调用带参构造。

## Leetcode 206 反转链表
双指针法，最后需要return prev. 因为此时cur已经到了原先链表的最后为null










