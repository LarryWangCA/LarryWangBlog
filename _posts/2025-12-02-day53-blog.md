---
layout: post
title: "个人代码训练营Day53-位运算day03"
date: 2025-12-02 & 12-16 10:00:00 -0400
categories: 随笔
---

# C++ Tips
C++负数的二进制表示等于按位取反（补码）再加一。  
```
 3  = 00000011
-3  = 11111101   (取反 + 1)
```

在 C++ 中：对「有符号负数」做左移 << 是 未定义行为（Undefined Behavior）  
所以在 LC 371 里，我们把进位用 unsigned 来算，避免 UB（不加也能AC，主要是由于编译器宽容和没有激进优化）。  


## Leetcode 201 Bitwise AND of Numbers Range（反复练习）
只要 m < n（十进制的比较，本质上和二进制比较没区别，此时区间还没收敛），它们之间一定存在 bit 变化 → 该 bit 在区间 AND 中必为 0 → 必须从 m 和 n 两边共同去掉。  
最终 m == n 时剩下的就是可能为 1 的全部公共前缀。

## Leetcode 338. Counting Bits
与1即可，注意右移一定要加等于号！n >>= 1.  

## Leetcode 231. Power of Two
与上题一样，二进制表达中只有一个1，即为2的幂。

## Leetcode 371. Sum of Two Integers （反复练习）
直接死记硬背即可，无论两个数的正负，CPU 做加法，本来就是用 xor + carry。  
xor 负责“加但不进位”，  
and + <<1 负责“算进位”，  
不断把进位加回去，直到没有进位为止。  

