---
layout: post
title: "代码训练营Day44-图论02"
date: 2025-11-13 10:00:00 -0400
categories: 随笔
tags: [graph]
---

# C++ Tips
以下常见的grid输入，输入时可以在同一行或多行输入，只要数字的总数量等于 n * m，cin 会自动按顺序读取。
```
    vector<vector<int>> grid(n, vector<int>(m, 0));
    for (int i = 0; i < n; i++) {
        for (int j = 0; j < m; j++) {
            cin >> grid[i][j];
        }
    }
```
对于pair<int,int>，只有 .first, .second；不能通过[]来索引。  
pair只能是两个元素，元素类型可以不同，超过两个元素需要用tuple。
push的时候记得加{}括号：e.g. que.push({x,y});  

注意main()函数中的变量作用于只有main函数，如果dfs/bfs在main()函数外定义，需要定义一个全局变量（和include同一位置）使得所有函数都能用。


## 卡码网 99 计数孤岛（反复练习）
本题是在常规for循环中判断哪块是未访问过的陆地（计算结果），dfs和bfs用来判断该陆地有哪些与之相连的陆地。 
int dir[4][2] = {0, 1, 1, 0, 0, -1, -1, 0};
用dir定义四个方向，然后输入当前坐标得到上下左右的坐标。
DFS：  
探索一个节点的上下左右四个方向，dfs方法即为朝着一个方向先搜索，处理完后在回到之前没处理过的方向上继续处理。  
本题dfs不需要回溯，因为visited数组是标记访问过的地方，回溯会出错（已经被访问过了，不能重复访问）。  
出现 visited 数组：一般不回溯。  
出现 path 或者记录答案数组：一般要回溯。

BFS:
即将每个点的四周都访问一遍，之后之后再处理下一个点。
注意：需要在添加到队列的时候标记为访问过（而不是从队列里取出的时候！），防止重复访问造成超时。

## 卡码网 100 岛屿的最大面积
本题与上题几乎相同，dfs和bfs都行。 
计数可以在主函数中（即发现主陆地记录为1，在递归中统计周围的面积；也可以完全在递归中计算面积。  





