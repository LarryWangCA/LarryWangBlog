---
layout: post
title: "个人代码训练营Day62"
date: 2026-02-01 10:00:00 -0400
categories: 随笔
---

# C++ Tips
int n = vec.size();   // 警告：从 size_t 到 int 可能丢失精度  
强制转换比较规范  int n = (int)vec.size();  
注意字符与字符串的区别，' '(char相关比较)与 " "（string相关操作），不能混为一谈！

## Leetcode 268. Missing Number （反复练习）
最蠢解法：sort后逐个比较，O(NlogN);  
中等：使用set，时间复杂度O(N),但是有额外的空间O(N).  
最优解法：利用XOR的性质（同为0，异为1），相同xor之后为0，剩下的那个就是缺的。   

LC268 变体：nums 已排序，可能不缺任何数字，数字可任意，要求 O(logN)   
这就是二分经典套路：  
如果本应连续，那么对于任意下标 i，理论值应为：  
expected(i) = nums[0] + i  
于是检查：  
	•	若 nums[mid] == nums[0] + mid：说明 缺口在右边  
	•	否则：说明 缺口在左边（含 mid）  
```
#include <vector>
using namespace std;

// 返回：pair<是否缺失, 缺失的数(若不存在则随便填)>
pair<bool, long long> findMissingConsecutiveSorted(const vector<long long>& nums) {
    int n = (int)nums.size();
    if (n == 0) return {false, 0};

    long long base = nums[0];
    int lo = 0, hi = n - 1;

    // 找第一个 nums[i] != base + i
    while (lo <= hi) {
        int mid = lo + (hi - lo) / 2;
        long long expected = base + mid;

        if (nums[mid] == expected) {
            lo = mid + 1;      // 左半段都对，缺口在右边
        } else {
            hi = mid - 1;      // mid 及左边可能有缺口
        }
    }

    if (lo == n) {
        // 全都满足 base+i，说明没缺
        return {false, 0};
    }
    // lo 是第一个不匹配的位置，缺的就是 base+lo
    return {true, base + lo};
}
```



## Leetcode 71. Simplify Path （反复练习）
不要去记那些getline, stringstream, 手动实现这些功能。  
以下代码有以下几个注意事项：  
1：用vector代替stack,因为我们只需要pop back（vector也可以pop back），因为这样输出结果的时候很方便，不用reverse。
2: 注意..的处理，我们得先判断part的内容，再决定是否push或者pop。如果是.则什么都不处理。  
3：注意字符与字符串的区别，''与""，不能混为一谈！
```
class Solution {
public:
    string simplifyPath(string path) {
        vector<string> st;               // 当栈用，存目录名
        int n = (int)path.size();
        int i = 0;

        while (i < n) {
            // 1) 跳过连续的 '/'
            while (i < n && path[i] == '/') i++;

            // 如果已经到结尾了，退出
            if (i >= n) break;

            // 2) 找到这一段目录名的结尾（下一个 '/' 或字符串末尾）
            int j = i;
            while (j < n && path[j] != '/') j++;

            // 3) 取出当前组件（目录名）
            //    substr(pos, len)
            //    这里 len = j - i
            string part = path.substr(i, j - i);

            // 4) 根据 part 分类处理
            if (part == "..") {
                if (!st.empty()) st.pop_back();   // 回到上一级
            } else if (part == ".") {
                // 当前目录，忽略
            } else {
                st.push_back(part);               // 正常目录名
            }

            // 5) i 移到下一段开始
            i = j;
        }

        // 6) 拼接答案
        if (st.empty()) return "/";

        string res;
        for (const string& dir : st) {
            res += "/" + dir;
        }
        return res;
    }
};
```

## Leetcode 82. Remove Duplicates from Sorted List II(反复练习)
dummy.next = head; 只是初始化让 dummy.next 指向原链表头；不管用没用到，一般先写上没有问题，之后也可以再修改。  
	•	prev 永远指向“已经处理完、确定保留”的最后一个节点  
	•	cur 用来探测 prev->next 开始是否存在重复段  
	•	有重复就 prev->next = cur->next 整段跳过；没重复就 prev = prev->next 往前推进.    
这种链表问题，一定要确保尾巴是否干净！（是否是个nullptr)  
```
class Solution {
public:
    ListNode* deleteDuplicates(ListNode* head) {
        ListNode dummy(0);
        dummy.next = head;
        ListNode* prev = &dummy;

        while (prev->next) {
            ListNode* cur = prev->next;

            // 走到这一段重复值的最后一个节点
            while (cur->next && cur->val == cur->next->val) {
                cur = cur->next;
            }

            // 如果没重复：prev 往前走一步
            if (prev->next == cur) {
                prev = prev->next;
            } else {
                // 有重复：跳过整段重复值
                prev->next = cur->next;
            }
        }
        return dummy.next;
    }
};
```

## Leetcode 510 Inorder Successor in BST II（反复练习） 
直接解法O(n) 空间 + O(n) 时间，inorder结果保存在vector中，查找node的下一个即可。
注意本题的输入是Node* node,需要通过该目标node的parent找到整个BST的root，然后再进行inorder。

高级解法 O(h) 时间、O(1) 空间
	1.	p 有右子树
后继 = p->right 这棵子树里 最左 的节点（一直走 left）。
	2.	p 没右子树
沿 parent 往上走，直到第一次出现：当前节点是它父亲的左孩子，那这个父亲就是后继。
如果一直走到 null 都没找到，说明 p 是最大值 → 没后继。
```
class Solution {
public:
    Node* inorderSuccessor(Node* p) {
        if (!p) return nullptr;

        // Case 1: right subtree exists -> leftmost of right subtree
        if (p->right) {
            Node* x = p->right;
            while (x->left) x = x->left;
            return x;
        }

        // Case 2: no right subtree -> go up until we come from left
        Node* cur = p;
        Node* par = p->parent;
        while (par && par->right == cur) { // came up from right, keep going up
            cur = par;
            par = par->parent;
        }
        return par; // could be nullptr
    }
};
```

## Leetcode 210. Course Schedule II（反复练习）
用BFS实现，1）找入度为0的节点添加到队列中 2）删节点（实际通过入度-1来实现）
adj领接表用来判断从这门课出发，会解锁哪些后续课程。  
inDegree用来判断每个课的入度数。
	•	有环 ⇒ 会出现一些点永远入度 > 0 ⇒ 永远不会进队 ⇒ 队列最终变空 ⇒ while 结束  
	•	所以检测环的方法就是：最后看 order.size() == numCourses 吗？不是就有环。  
```
class Solution {
public:
    vector<int> findOrder(int numCourses, vector<vector<int>>& prerequisites) {
        vector<vector<int>> adj(numCourses);
        vector<int> indeg(numCourses, 0);

        // prereq: [a, b] means b -> a (take b before a)
        for (auto &e : prerequisites) {
            int a = e[0], b = e[1];
            adj[b].push_back(a);
            indeg[a]++;
        }

        queue<int> q;
        for (int i = 0; i < numCourses; ++i) {
            if (indeg[i] == 0) q.push(i);
        }

        vector<int> order;
        order.reserve(numCourses);

        while (!q.empty()) {
            int u = q.front(); q.pop();
            order.push_back(u);

            for (int v : adj[u]) {
                if (--indeg[v] == 0) q.push(v);
            }
        }

        if ((int)order.size() != numCourses) return {}; // has cycle
        return order;
    }
};
```

## Leetcode 1351. Count Negative Numbers in a Sorted Matrix（反复练习）
暴力解法for循环嵌套。O(N^2) 

优化解法1（只用到了行的递减性质 O(NlogN) ）：对每一行使用binary search。 
注意本题不是找“等于某个值”，而是找边界（注意与LC704的区别！）：每行里“第一个负数”的位置（也叫 lower_bound）
即使mid是负数，也要保存结果并继续向左查看是否有更早的负数。
```
            int l = 0, r = n-1;
            int pos = n;
            //binary search to find the 1st negative values;
            while (l <= r){
                int mid = l + (r-l)/2;
                if (grid[i][mid] < 0){
                    r = mid-1;
                    pos = mid;
                }else{
                    l = mid+1;
                }
            }
```

优化解法2（同时运用行和列的递减性质）O(m+n)
从后往前，找到第一行的index，
此后的每一行，index之后不变或者增加。  
为什么是 O(m+n)？
	•	currRowNegativeIndex 从 n-1 最多只会减到 -1，总共最多减 n 次
	•	外层遍历 m 行
	•	所以总操作 ≈ m + n





















