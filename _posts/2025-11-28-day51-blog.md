---
layout: post
title: "个人代码训练营Day51-位运算day01"
date: 2025-11-28 10:00:00 -0400
categories: 随笔
---

# C++ Tips:
char(0)不等于‘0’；而是ascii值为0对应的符号。
要把 数字 0、1 转成 字符 ‘0’、‘1’，必须加 '0'；反之则是减去'0'。

即使输入/打印是十进制，位运算总是在操作二进制位。
而且这就是位运算强大的原因，它可以直接精确控制每一位 bit：  
	•	取最低位：x & 1  
	•	设置某一位为 1：x |= (1 << k)  
	•	清除某一位：x &= ~(1 << k)  
	•	翻转某一位：x ^= (1 << k)  
	•	左移、右移：x << k, x >> k  
这些全部是 对二进制位的操作，与十进制没有直接关系。

## Leetcode 67 二进制加法（反复练习）
	•	从后往前：i = a.size()-1, j = b.size()-1  
	•	有一位没走完 or 有进位：就继续循环  
	•	每步：  
	•	sum = carry + (a位) + (b位)  
	•	当前位 = sum % 2  
	•	carry = sum / 2  
	•	结果字符串最后要 reverse  

## Leetcode 190 Reverse Bits（反复练习）
虽然输入是整数，但是左移右移操作本质上都是在二进制上进行的（位运算始终按 二进制位 操作，不管输入是十进制还是别的）。  
	•	输入是 32-bit 无符号整数，必须反转所有 32 位（不能提前结束）。  
	•	反转的做法：每次取 n 的最低位 → 放到结果的最高位方向。  

## Leetcode 191 Number of 1 bits
同上，即使n很小（十进制），在计算机中的二进制表示依然是32位，需要循环32次。
最低位&1然后右移即可。









