---
layout: post
title: "代码训练营Day14-二叉树04"
date: 2025-10-06 10:00:00 -0400
categories: 随笔
---
#Tips：
如果需要搜索整棵二叉树且不用处理递归返回值，递归函数就不要返回值。（这种情况就是本文下半部分介绍的113.路径总和ii）
如果需要搜索整棵二叉树且需要处理递归返回值，递归函数就需要返回值。 （这种情况我们在236. 二叉树的最近公共祖先中介绍）
如果要搜索其中一条符合条件的路径，那么递归一定需要返回值，因为遇到符合条件的路径了就要及时返回。（Leetcod 112 路径总和i）

#C++ Tips
```
vector<int> sub(v.begin(), v.begin() + 3); //先天为左闭右开
表示取从 v.begin() 开始(第一个元素， = v.begin()+0)，到 v.begin() + 3 (第四个元素)之前的所有元素。 //即前三个元素
v.end()-1即为最后一个元素（v.end()是最后一个元素之后的下一个位置）
```


## Leetcode 513 找树左下角的值
层序遍历法很简单，将最后一层第一个值返回即可。
递归法即为使用递归的方式找到最大的深度，然后cur->val即为最左边的值（因为无论前中后序，左都在右之前，所以三种递归都可以，注意深度计算也需要回溯）
```
class Solution {
public:
    int maxDepth = INT_MIN;
    int result;
    void traversal(TreeNode* root, int depth) {
        if (root->left == NULL && root->right == NULL) {
            if (depth > maxDepth) {
                maxDepth = depth;
                result = root->val;
            }
            return;
        }
        if (root->left) {
            depth++;
            traversal(root->left, depth);
            depth--; // 回溯
        }
        if (root->right) {
            depth++;
            traversal(root->right, depth);
            depth--; // 回溯
        }
        return;
    }
    int findBottomLeftValue(TreeNode* root) {
        traversal(root, 0);
        return result;
    }
};
```

## Leetcode 112 路径总和 I
本题的dfs函数需要有返回值bool,本题属于一旦找到一个结果就要返回，节点访问顺序是前序，逻辑处理顺序类似于后序，从底向上返回结果。
本题逻辑上用sum逐渐减掉节点的值，然后判断是否为0，比较简单。
```
class Solution {
public:
    bool traversal(TreeNode* cur, int count){
        //找到了符合条件的一条路径(肯定是在叶子节点处)
        if (!cur->left && !cur->right && count == 0)
            return true;
        //剪枝，叶子count不为0直接返回
        if (!cur->left && !cur->right) 
            return false;
        //向左遍历
        if (cur->left){
            count -= cur->left->val;
            if (traversal(cur->left, count)) return true;
            count += cur->left->val;
        }
        //向右遍历
        if (cur->right){
            count -= cur->right->val;
            if (traversal(cur->right, count)) return true;
            count += cur->right->val;
        }
        //遍历完整棵树没结果
        return false;
        
    }

    bool hasPathSum(TreeNode* root, int targetSum) {
        if (!root) return false;
        return traversal(root, targetSum - root->val);
    }
};
```
## Leetcode 113 路径总和 II
本题dfs不需要返回值，因为需要遍历完整颗树才能收集到所有路径，用全局变量收集即可。
本题需要记得path也得backtracking，而且根节点需要提前放到path中(每个path都会包含这个根节点)。


## Leetcode 106 从中序和后续遍历构造二叉树(反复练习)
核心思想：后序最后一个元素为中间节点，用这个元素切割中序，中序得出左中序和右中序大小后，用该大小接着切后序。接下来递归处理左右区间即可。
切割时，一定要确保区间逻辑一致，即都是左闭右开或者左开右闭。可以通过pop_back()弹出vector最后一个元素(切割比较方便，不弹出也无所谓)

## Leetcode 105 从中序和前续遍历构造二叉树
与leetcode106没有明显区别，需要注意前序的中为第一个元素，通过erase删除第一个元素erase(A.begin()) (切割比较方便，不弹出也无所谓)
当前切割法空间复杂度比较差(O(n^2))，因为每次都要复制新的数组,二刷的时候尝试用下标法O(N).




