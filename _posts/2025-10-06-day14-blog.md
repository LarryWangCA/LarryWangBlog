---
layout: post
title: "代码训练营Day13-二叉树04"
date: 2025-10-06 10:00:00 -0400
categories: 随笔
---
#Tips：
如果需要搜索整棵二叉树且不用处理递归返回值，递归函数就不要返回值。（这种情况就是本文下半部分介绍的113.路径总和ii）
如果需要搜索整棵二叉树且需要处理递归返回值，递归函数就需要返回值。 （这种情况我们在236. 二叉树的最近公共祖先中介绍）
如果要搜索其中一条符合条件的路径，那么递归一定需要返回值，因为遇到符合条件的路径了就要及时返回。（Leetcod 112 路径总和i）



## Leetcode 513 找树左下角的值
层序遍历法很简单，将最后一层第一个值返回即可。
递归法即为使用递归的方式找到最大的深度，然后cur->val即为最左边的值（因为无论前中后序，左都在右之前，所以三种递归都可以，注意深度计算也需要回溯）
```
class Solution {
public:
    int maxDepth = INT_MIN;
    int result;
    void traversal(TreeNode* root, int depth) {
        if (root->left == NULL && root->right == NULL) {
            if (depth > maxDepth) {
                maxDepth = depth;
                result = root->val;
            }
            return;
        }
        if (root->left) {
            depth++;
            traversal(root->left, depth);
            depth--; // 回溯
        }
        if (root->right) {
            depth++;
            traversal(root->right, depth);
            depth--; // 回溯
        }
        return;
    }
    int findBottomLeftValue(TreeNode* root) {
        traversal(root, 0);
        return result;
    }
};
```











