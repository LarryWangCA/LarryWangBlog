---
layout: post
title: "代码训练营Day47-图论05"
date: 2025-11-16 10:00:00 -0400
categories: 随笔
tags: [graph]
---

## 并查集（Union Find）理论基础
并查集作用：
	1.	合并两个人到同一组（union 操作）
	2.	判断两个人是不是同一组（find 操作）
```
// 并查集初始化
void init() {
    for (int i = 0; i < n; ++i) {
        father[i] = i;
    }
}


// (传统)并查集里寻根的过程
int find(int u) {
    if (u == father[u]) return u; // 如果根就是自己，直接返回
    else return find(father[u]); // 如果根不是自己，就根据数组下标一层一层向下找
}

// (路径压缩后)并查集里寻根的过程
int find(int u) {
    if (u == father[u]) return u;
    father[u] = find(father[u]); // 路径压缩
    return father[u];
//或者写为一行
  return father[u] = find(father[u]);
}

// 将v，u 这条边加入并查集
void join(int u, int v) {
    u = find(u); // 寻找u的根
    v = find(v); // 寻找v的根
    if (u == v) return; // 如果发现根相同，则说明在一个集合，不用两个节点相连直接返回
    father[v] = u;
}

// 判断 u 和 v是否找到同一个根
bool isSame(int u, int v) {
    u = find(u);
    v = find(v);
    return u == v;
}
```
find寻根的路径压缩：路径压缩对第一次查找几乎没加速作用，但能让之后的查找几乎是 O(1) 的！  
并查集永远是从子指向父！
在join函数中 我们需要寻找 u 和 v 的根，然后再进行连线在一起，而不是直接 用 u 和 v 连线在一起！
常见误区：  
join(1,2);
join(3,2);
join完成后是2 → 1 → 3  
误区1：并不是2->1, 2->3:因为join会寻找2的根，用1连接3.
误区2：此时并没有路径压缩到2->3,因为执行find的时候join未完成，此时2的根仍是1，之后再次find才能压缩到新根。

## 卡码网 107 寻找存在的路线（并查集模版题） 
也可以用dfs，bfs来解决(O(n+m))。但因为无向，适合并查集（路径压缩后接近O(1)）。
并查集内部是有方向的树结构（内部逻辑only），但它用来判断的是“两个节点是否在同一集合中”，这是无向关系，因此非常适合处理无向图的连通问题。
本题直接使用并查集模版即可（因为是无向图，判断是否在同一集合中）。  















