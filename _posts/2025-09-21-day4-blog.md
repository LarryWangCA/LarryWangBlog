---
layout: post
title: "代码训练营Day4-链表02"
date: 2025-09-20 21:00:00 -0400
categories: 随笔
---

’‘’
NULL/nullptr指的是指针存的地址（内容）为空（指针自己是存在的，它的地址一定存在）
while (cur) 和 if (cur) 判断逻辑一致：
判断的是指针里存的地址值是否为 nullptr。
它们不会去管“指针变量自身的地址”。
‘’‘

## Leetcode 24 两两交换链表中的节点
模拟题，依照题意直接做即可;
需要注意随着cur在循环里面的前进，相应的temp也需要在循环内前进。

## Leetcode 19 删除链表的倒数第N个节点
双指针（快慢指针），快指针比慢指针快N个节点
先将快指针比慢指针快N，然后同时移动快慢指针即可
需要注意，如果快慢指针在虚拟头节点上，让快指针比慢指针快N需要(N+1)个->next
现实中删除的节点需要delete那个node(因为是heap allocated, 不手动管理会造成内存泄漏)
在leetcode中不删除节点不影响题目是否通过。

## Leetcode 160 链表相交
swap(lenA, lenB):交换数值（int）
swap(curA, curB):交换指针存的地址值
swap属于就地换位
根据Linked List的定义，每个节点只有一个后继指针next，指向唯一的后继节点！
一开始相同，后续分叉的链表是不存在的（不符合单链表的定义）
所以本题只需要找到链表的终点，到退后相同的起点（基于长度的差），然后判断指针是否相同即可

## Leetcode 142 环形链表 II
[flyod判圈法]
1：判断是否有环：slow指针一次一步，fast指针一次两步，如果有环，快慢指针终将相遇。
Tips: 只要fast比slow快就一定会相遇，只不过快一步比较简单，容易理解。  
如果快N步的话，相遇的位置可能是固定在某些节点，取决于fast和slow的最大公约数。  
2：判断环的入口：将慢指针放回head，快慢指针再次相遇的地方即为环的入口
Tips：
’‘’
x = 从头到环入口的距离
y = 从环入口到第一次相遇点的距离
c = 环的长度
相遇时有：2(x+y) = x+y + k*c（快指针比慢指针多走了若干个整环），得
x + y = k*c => x = k*c - y = (k-1)*c + (c - y)。
记 z = c - y 是从相遇点到入口的距离。于是 x = (k-1)*c + z。
把一个指针放回头后，两指针同速前进：从头走 x 步到入口；从相遇点走 x 步等于先在环里转 (k-1) 圈再走 z 步，同样到入口。所以会在入口相遇
‘’‘















