---
layout: post
title: "代码训练营Day32-动态规划05"
date: 2025-10-28 10:00:00 -0400
categories: 随笔
tags: [dp]
---

# C++ Tips
int有可能会overflow，正整数将int改为uint64_t即可。

## 完全背包
和01背包的区别：01背包一个物品只能使用一次，完全背包一个物品可以使用无数次。
### 二维数组解法：
dp[i][j] 表示从下标为[0-i]的物品，每个物品可以取无限次，放进容量为j的背包，价值总和最大是多少。
递推公式：
dp[i][j] = max(dp[i-1][j], dp[i][j - weight[i]] + value[i])
	•	第一项 dp[i-1][j]：不放物品 i
	•	第二项 dp[i][j - weight[i]] + value[i]：放至少一个物品 i
（在之前的状态中可能已经放过 i 若干次）
第二项的理解：那么放完一个物品 i 之后，**背包剩余容量 j-weight[i] 的状态仍然可以继续放物品 i **！
遍历顺序：先遍历物品还是背包都可以，背包容量从小到大遍历。
注意事项！！！我们需要判断j和weight[i]的大小关系(小于时直接继承上一行，因为该物品放不进去)：
```
for (int i = 1; i < n; i++) {
    for (int j = 0; j <= bagWeight; j++) {
        if (j < weight[i]) dp[i][j] = dp[i - 1][j];
        else dp[i][j] = max(dp[i - 1][j], dp[i][j - weight[i]] + value[i]);
    }
}
```
初始化：初始化第一行和第一列即可，当j >= weight[0]时，dp[0][j] 如果能放下weight[0]的话，就一直装，每一种物品有无限个。
### 一维数组解法
dp[j]: 所有物品，每个物品可以取无限次，放进容量为j的背包，价值总和最大是多少。
递推公式（二维中去掉i层数据维度）：
dp[j] = max(dp[j], dp[j - weight[i]] + value[i])
遍历顺序：先遍历物品还是背包都可以（prefer外层物品内层背包），背包容量从小到大遍历。
注意事项！！！先遍历物品后遍历背包，此时内层for循环从j=weight[i]即可：
```
for (int i = 0; i < 2; i++) {
    for (int j = weight[i]; j <= 5; j++) {
        dp[j] = max(dp[j], dp[j - weight[i]] + value[i]);
    }
}
```
先遍历背包后遍历物品则j只能从0开始（因为物品的重量不是排序的），此时只能在循环内加if判断。
初始化：初始化为0即可。

## Leetcode 518 零钱兑换 II
本题属于求组合数（注意是组合不是排列数！），用回溯法会超时。
### 二维数组解法
定义二维dp数值 dp[i][j]：使用 下标为[0, i]的coins[i]能够凑满j（包括j）这么大容量的包，有dp[i][j]种组合方法。
递推公式：dp[i][j] = dp[i - 1][j] + dp[i][j - nums[i]] （参考LC494目标和，区别是01和完全）
遍历顺序：无要求，注意循环内的if判断。
```
        // 以下遍历顺序行列可以颠倒
        for (int i = 1; i < coins.size(); i++) { // 行，遍历物品
            for (int j = 0; j <= bagSize; j++) { // 列，遍历背包
                if (coins[i] > j) dp[i][j] = dp[i - 1][j]; 
                else dp[i][j] = dp[i - 1][j] +  dp[i][j - coins[i]];
            }
        }
```
初始化：第一行和第一列。
第一行：取决于:if (j % coins[0] == 0) dp[0][j] = 1;(注意是方法数不是个数)
第一列：背包容量为0，都不装，也是一种方法，所以均为1。

### 一维数组解法
dp[j]：凑成总金额j的货币组合数为dp[j]。
递推公式：dp[j] += dp[j - coins[i]] （二维压缩为一维，与01背包相同）
初始化：dp[0]=1,其余均为0。（需要累加计算）
遍历顺序：
外层为物品，内层为背包，从小到大遍历，不能颠倒！（求组合数）
如果外层为背包，内层为物品，则是排列数！
	•	初始：dp[0] = 1，其他为 0。
	•	遍历硬币时，每个 dp[j] 是在原有基础上累加 dp[j - coin]。
	•	若 dp[j - coin] == 0，说明当前硬币组合凑不出该金额，dp[j] 不变。
	•	因此 dp[j] 在中途可能为 0，这是正常的，表示该金额暂时不可达。
	•	当出现新的可达路径后（某次 dp[j - coin] > 0），dp[j] 才开始增加
```
for (int i = 0; i < coins.size(); i++) { // 遍历物品
    for (int j = coins[i]; j <= amount; j++) { // 遍历背包容量
        dp[j] += dp[j - coins[i]];
    }
}
```
时间复杂度: O(mn)，其中 m是amount，n 是 coins 的长度
空间复杂度: O(m) //dp数组大小

## Leetcode 377 组合总和 IV
本题和上题的区别，上题是组合，这题是排列，其余没有区别。
dp[j]：凑成target的排列数为dp[j]。
递推公式：dp[j] += dp[j - nums[i]] （二维压缩为一维，与01背包相同）
初始化：dp[0]=1,其余均为0.
遍历顺序：
外层为背包，内层为物品，从小到大遍历，不能颠倒！（求排列数)
我个人习惯用j遍历背包，i遍历物品，与其内层外层没关系。
```
        for (int j = 0; j <= target; j++){
            for (int i = 0; i < nums.size(); i++ ){
                if (j - nums[i] >= 0)
                    dp[j] += dp[j-nums[i]];
            }
        }
```

## 爬楼梯进阶
每次可以走的步数为m步（而不再是固定的一步或者两步），求走到n的方法数。
本题即可转化为完全背包的排列问题，与上题几乎一致。
```
        for (int j = 1; j <= n; j++){
            for (int i = 1; i <= m; i++ ){
                if (j - i >= 0)
                    dp[j] += dp[j-i];
            }
        }
```








