---
layout: post
title: "代码训练营Day32-动态规划05"
date: 2025-10-28 10:00:00 -0400
categories: 随笔
---

## 完全背包
和01背包的区别：01背包一个物品只能使用一次，完全背包一个物品可以使用无数次。
# 二维数组解法：
dp[i][j] 表示从下标为[0-i]的物品，每个物品可以取无限次，放进容量为j的背包，价值总和最大是多少。
递推公式：
dp[i][j] = max(dp[i-1][j], dp[i][j - weight[i]] + value[i])
	•	第一项 dp[i-1][j]：不放物品 i
	•	第二项 dp[i][j - weight[i]] + value[i]：放至少一个物品 i
（在之前的状态中可能已经放过 i 若干次）
注意事项！！！我们需要判断j和weight[i]的大小关系(小于时直接继承上一行，因为该物品放不进去)：
```
for (int i = 1; i < n; i++) {
    for (int j = 0; j <= bagWeight; j++) {
        if (j < weight[i]) dp[i][j] = dp[i - 1][j];
        else dp[i][j] = max(dp[i - 1][j], dp[i][j - weight[i]] + value[i]);
    }
}
```
第二项的理解：那么放完一个物品 i 之后，**背包剩余容量 j-weight[i] 的状态仍然可以继续放物品 i **！
遍历顺序：先遍历物品还是背包都可以，背包容量从小到大遍历。
初始化：初始化第一行和第一列即可，当j >= weight[0]时，dp[0][j] 如果能放下weight[0]的话，就一直装，每一种物品有无限个。
# 一维数组解法
dp[j]: 所有物品，每个物品可以取无限次，放进容量为j的背包，价值总和最大是多少。
递推公式：





