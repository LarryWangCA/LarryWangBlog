---
layout: post
title: "代码训练营Day6-哈希表02"
date: 2025-09-23 10:00:00 -0400
categories: 随笔
---

## Leetcode 454 四数相加 II
本题不需要去重，所以相对简单，用unordered_map判断a+b(前两个数组)次数，再通过-（c+d）判断（后两个数组）  

因为一个key对应的freq不一定是一，所以count是加上对应的freq而不是直接count++

## Leetcode 383 Ransom Note(赎金信)
用数组实现map（map空间消耗大且费时）  

判断ransomNote中的字符能否由magazine组成即可

## Leetcode 15 三数之和（有意义，需要重做）
双指针法：第一个数，for循环控制遍历整个数组，之后两个数，left在最左边(第一个数+1)，right在最右边(数组末尾)逐渐向中间靠拢（输入数组本身需要排序）

因为结果不能有重复的三元组，所以每个数都要去重！  

但是结果集本身内部元素可以重复！ (-1, -1, 2)  

第一个数去重逻辑：nums[i] == nums[i-1];不是i+1否则(-1.-1.2)无法被获取  

第二三个数去重逻辑：收获结果后开始去重，否则{0,0,0}无法获取；
```
                    while (left < right && nums[left] == nums[left+1]) 
                        left++;
                    while (left < right && nums[right] == nums[right-1]) 
                        right--;
                    left++;
                    right--;
```
必须判断left<right进行去重,并且最后才是left和right的自增自减（否则会少结果 e.g. [-2 0 1 1 2], -2,1,1无法获取）！
Time: O(n^2)

## Leetcode 18 四数之和
本质上和三数之和相同，再多加一层for循环即可，剪枝时需要判断是否为正(两个负数相加会越来越小，target可以是负数)

Time: O(n^3)
需要使用long防止四数相加之后溢出：
```
Windows (LLP64): int = 32-bit, long = 32-bit, long long = 64-bit

Linux/macOS (LP64): int = 32-bit, long = 64-bit, long long = 64-bit

Ranges you’ll see in practice

If a type is n bits and signed (two’s complement), range is [−2^(n−1), 2^(n−1)−1]. Unsigned is [0, 2^n−1].
```













