---
layout: post
title: "代码训练营Day30-动态规划03"
date: 2025-10-26 10:00:00 -0400
categories: 随笔
tags: [dp]
---

## 01背包问题
题目描述：有n件物品和一个最多能背重量为w 的背包。第i件物品的重量是weight[i]，得到的价值是value[i] 。每件物品只能用一次，求解将哪些物品装入背包里物品价值总和最大。
# 二维数组解法：
dp数组含义：dp[i][j]：从下标为[0-i]的物品里任意取，放进容量为j的背包，价值总和最大是多少。
递推过程（更具体的看代码随想录官网）
不放物品i：背包容量为j，里面不放物品i的最大价值是dp[i - 1][j]。
放物品i：背包空出物品i的容量后，背包容量为j - weight[i]，dp[i - 1][j - weight[i]] 为背包容量为j - weight[i]且不放物品i的最大价值，
那么dp[i - 1][j - weight[i]] + value[i] （物品i的价值），就是背包放物品i得到的最大价值。
递归公式： dp[i][j] = max(dp[i - 1][j], dp[i - 1][j - weight[i]] + value[i]);
dp数组初始化：
第一行和第一列需要初始化，其余位置均可有正上方和斜上方推到而来。
第一列：背包容量为0，此时放不下任何物品，均为0。
第一行：如果背包容量>=物品0的重量，则dp[0][j]=value[0](物品0的价值)，其余为0
遍历顺序：本题是二维dp数组，需要两个for循环嵌套。
因为每一个元素都由正上方和左上方推导而来，需要确保遍历到该处时其递推公式里的元素已经被递推赋值过，所以先遍历背包（内层）或者先遍历物品（内层）都可以。
```
    for(int i = 1; i < weight.size(); i++) { // 遍历科研物品，从1开始时因为第一行已经在初始化过程中被赋值了
        for(int j = 0; j <= bagweight; j++) { // 遍历行李箱容量
            if (j < weight[i]) dp[i][j] = dp[i - 1][j]; // 如果装不下这个物品,那么就继承dp[i - 1][j]的值
            else {
                dp[i][j] = max(dp[i - 1][j], dp[i - 1][j - weight[i]] + value[i]);
            }
        }
    }
```
# 一维数组（滚动数组）解法：
根据上方的二维数组可知，当前元素由上一行推导而来，此时我们可以去掉i这一个维度。
dp数组含义：dp[j]为 容量为j的背包所背的最大价值。
递推过程
不放物品i:为dp[j]，理解为物品i不影响此时背包所装的最大价值（与二维match）
放物品i:dp[j-weigh[i]]+value[i]即为此时的最大价值（与二维match）
dp数组初始化：看一下递归公式：dp[j] = max(dp[j], dp[j - weight[i]] + value[i]);
dp数组在推导的时候一定是取价值最大的数，如果题目给的价值都是正整数那么非0下标都初始化为0就可以了。
遍历顺序：也是两个for循环嵌套，但是与二维有很大区别
内层必须是倒序遍历背包：
1）倒序：确保每个物品不会被多次添加，防止已经更新的值被再次被用于更新。
2）内层必须是遍历背包，外层是正序（倒序也行，统一用正序）遍历物品：与倒序有关（会重复用同一物品）。
也可以理解为保留二维的逻辑，一次只处理一个物品。
```
    for(int i = 0; i < weight.size(); i++) { // 遍历科研物品
        for(int j = bagweight; j >= weight[i]; j--) { // 遍历行李箱容量
            dp[j] = max(dp[j], dp[j - weight[i]] + value[i]);
        }
    }
```
优先使用一维数组，因为空间复杂度更优。

## Leetcode 416 分割等和子集（反复练习）
暴力法：使用回溯暴力搜索出所有组合，看是否有一个组合等于target，会超时。
因为本题每个元素只能使用一次，可以抽象为01背包，本题每个元素的数值即是重量，又是价值。
01背包中，dp[j] 表示： 容量（所能装的重量）为j的背包，所背的物品价值最大可以为dp[j]。
如果背包所载重量为target， dp[target]就是装满 背包之后的总价值，因为 本题中每一个元素的数值既是重量，也是价值，所以，当 dp[target] == target 的时候，背包就装满了。   
01背包的递推公式为：dp[j] = max(dp[j], dp[j - weight[i]] + value[i]);
本题，相当于背包里放入数值，那么物品i的重量是nums[i]，其价值也是nums[i]。
所以递推公式：dp[j] = max(dp[j], dp[j - nums[i]] + nums[i])。  
初始化：与01背包相同，初始为0。
遍历顺序：与01背包相同。

## Leetcode 3742. Maximum Path Score in a Grid (进阶，目前没做，只想了思路)
本体属于01背包+unique path II的结合!是一道好题！  
维度对应经典问题说明移动方式Unique Paths只能右/下走，从 (0,0) 到 (m-1,n-1)。  
状态转移Unique Paths DPdp[i][j] 表示到达 (i,j) 的某种状态。
额外维度：成本01背包多一维 cost，记录已用预算。
选择物品（格子）01背包每个格子像一个“物品”：必须选（因为必须经过）。
优化目标01背包在 cost ≤ k 下，最大化 score。

dp[i][j][c] = 从起点走到 (i,j)，花费恰好 c 的最大得分
递推公式:dp[i][j][c] = max(dp[i-1][j][c-cost] + score, dp[i][j-1][c-cost] + score)
初始化：
为什么只初始化 dp[0][0][cost0]？
因为：
起点 (0,0) 是唯一可以“无前驱”到达的位置
所有其他格子都必须从 上 或 左 转移过来
所以：
dp[0][0][cost0] = score0  → 起点状态
其他 dp[i][j][c] = INT_MIN → 表示“尚未到达”或“不可达”
遍历顺序：（格子）从左到右，从上到下，（花费）从小到大。

Unique Pathsdp[i][j] = dp[i-1][j] + dp[i][j-1]
01背包dp[c] = max(dp[c], dp[c-w] + v)
本题dp[i][j][c] = max(dp[i-1][j][c-cost] + score, dp[i][j-1][c-cost] + score)













