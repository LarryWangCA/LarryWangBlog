---
layout: post
title: "代码训练营Day30-动态规划03"
date: 2025-10-26 10:00:00 -0400
categories: 随笔
---

## 01背包问题
题目描述：有n件物品和一个最多能背重量为w 的背包。第i件物品的重量是weight[i]，得到的价值是value[i] 。每件物品只能用一次，求解将哪些物品装入背包里物品价值总和最大。
# 二维数组解法：
dp数组含义：dp[i][j]：从下标为[0-i]的物品里任意取，放进容量为j的背包，价值总和最大是多少。
递推过程（更具体的看代码随想录官网）
不放物品i：背包容量为j，里面不放物品i的最大价值是dp[i - 1][j]。
放物品i：背包空出物品i的容量后，背包容量为j - weight[i]，dp[i - 1][j - weight[i]] 为背包容量为j - weight[i]且不放物品i的最大价值，
那么dp[i - 1][j - weight[i]] + value[i] （物品i的价值），就是背包放物品i得到的最大价值。
递归公式： dp[i][j] = max(dp[i - 1][j], dp[i - 1][j - weight[i]] + value[i]);
dp数组初始化：
第一行和第一列需要初始化，其余位置均可有正上方和斜上方推到而来。
第一列：背包容量为0，此时放不下任何物品，均为0。
第一行：如果背包容量>=物品0的重量，则dp[0][j]=value[0](物品0的价值)，其余为0
遍历顺序：本题是二维dp数组，需要两个for循环嵌套。
因为每一个元素都由正上方和左上方推导而来，需要确保遍历到该处时其递推公式里的元素已经被递推赋值过，所以先遍历背包（内层）或者先遍历物品（内层）都可以。
```
    for(int i = 1; i < weight.size(); i++) { // 遍历科研物品，从1开始时因为第一行已经在初始化过程中被赋值了
        for(int j = 0; j <= bagweight; j++) { // 遍历行李箱容量
            if (j < weight[i]) dp[i][j] = dp[i - 1][j]; // 如果装不下这个物品,那么就继承dp[i - 1][j]的值
            else {
                dp[i][j] = max(dp[i - 1][j], dp[i - 1][j - weight[i]] + value[i]);
            }
        }
    }
```
# 一维数组（滚动数组）解法：
根据上方的二维数组可知，当前元素由上一行推导而来，此时我们可以去掉i这一个维度。
dp数组含义：dp[j]为 容量为j的背包所背的最大价值。
递推过程
不放物品i:为dp[j]，理解为物品i不影响此时背包所装的最大价值（与二维match）
放物品i:dp[j-weigh[i]]+value[i]即为此时的最大价值（与二维match）
dp数组初始化：看一下递归公式：dp[j] = max(dp[j], dp[j - weight[i]] + value[i]);
dp数组在推导的时候一定是取价值最大的数，如果题目给的价值都是正整数那么非0下标都初始化为0就可以了。
遍历顺序：也是两个for循环嵌套，但是与二维有很大区别
内层必须是倒序遍历背包：
1）倒序：确保每个物品不会被多次添加，防止已经更新的值被再次被用于更新。
2）内层必须是遍历背包，外层是正序（倒序也行，统一用正序）遍历物品：与倒序有关（会重复用同一物品）。
也可以理解为保留二维的逻辑，一次只处理一个物品。
```
    for(int i = 0; i < weight.size(); i++) { // 遍历科研物品
        for(int j = bagweight; j >= weight[i]; j--) { // 遍历行李箱容量
            dp[j] = max(dp[j], dp[j - weight[i]] + value[i]);
        }
    }
```
优先使用一维数组，因为空间复杂度更优。

## Leetcode 416 分割等和子集（反复练习）
暴力法：使用回溯暴力搜索出所有组合，看是否有一个组合等于target，会超时。
因为本题每个元素只能使用一次，可以抽象为01背包，本题每个元素的数值即是重量，又是价值。
01背包中，dp[j] 表示： 容量（所能装的重量）为j的背包，所背的物品价值最大可以为dp[j]。
如果背包所载重量为target， dp[target]就是装满 背包之后的总价值，因为 本题中每一个元素的数值既是重量，也是价值，所以，当 dp[target] == target 的时候，背包就装满了。   
01背包的递推公式为：dp[j] = max(dp[j], dp[j - weight[i]] + value[i]);
本题，相当于背包里放入数值，那么物品i的重量是nums[i]，其价值也是nums[i]。
所以递推公式：dp[j] = max(dp[j], dp[j - nums[i]] + nums[i])。  
初始化：与01背包相同，初始为0。
遍历顺序：与01背包相同。















