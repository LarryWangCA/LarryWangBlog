---
layout: post
title: "代码训练营Day11-二叉树01"
date: 2025-09-30 10:00:00 -0400
categories: 随笔
---

## Leetcode 144, 145, 95 二叉树前/中/后序遍历
直接递归用dfs即可，判断‘中’在哪儿然后此处push_back。  
迭代法(基于stack的循环法)需掌握，统一迭代法目前跳过。   

## Leetcode 102 二叉树的层序遍历（bfs重要模版）

注意size的大小需要在while外面确认，因为里面的while会实时更新queue，在某些时间que既有当前层，也有下一层的节点
```
class Solution {
public:
    vector<vector<int>> levelOrder(TreeNode* root) {
        vector<vector<int>> res;
        queue<TreeNode*> que;
        
        if (!root) 
            return {};
        else
            que.push(root);

        while(!que.empty()){
            int size = que.size();
            vector<int> vec;
            while(size--){
                TreeNode* cur = que.front();
                que.pop();
                vec.push_back(cur->val);
                if (cur->left) que.push(cur->left);
                if (cur->right) que.push(cur->right);
            }
            res.push_back(vec);
        }    
        return res;
    }
};
```

## Leetcode 637 二叉树的层平均值
可以内层使用for循环，因为结果为float型，需要将sum定义为float型， float / int的结果为float。   

## Leetcode 429 N叉树的层序遍历
```
// Definition for a Node.
class Node {
public:
    int val;
    vector<Node*> children;

    Node() {}

    Node(int _val) {
        val = _val;
    }

    Node(int _val, vector<Node*> _children) {
        val = _val;
        children = _children;
    }
};
```
根据上述定义，需要使用cur->children[i]来访问每一个孩子的指针。

## Leeetcode 515 每个二叉树行中找到最大值
定义一个int max = INT_MIN, 然后将每行的每个值与其比较即可。
















