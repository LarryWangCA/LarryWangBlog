---
layout: post
title: "代码训练营Day40-动态规划13"
date: 2025-11-06 10:00:00 -0400
categories: 随笔
tags: [dp]
---

# C++ Tips (from LC weekly contest 474)
1: while()循环的判断条件是只要不为0就执行（bool类型），小于0时依然执行。
2：溢出处理需要在乘法过程中进行。
```
int a = 50000, b = 50000;
long long ans1 = a * b;            // ❌ int 溢出后再转 long long，错误
long long ans2 = (long long)a * b; // ✅ 提升后乘法，正确
```

## Leetcode 647 回文子串
布尔类型的dp[i][j]：表示区间范围[i,j] （注意是左闭右闭）的子串是否是回文子串，如果是dp[i][j]为true，否则为false。
递推公式：
```
if (s[i] == s[j]) {
    if (j - i <= 1) { // 情况一 和 情况二
        result++;
        dp[i][j] = true;
    } else if (dp[i + 1][j - 1]) { // 情况三
        result++;
        dp[i][j] = true;
    }
}
```
全部初始化为false即可。
遍历顺序：从下往上，从左往右!dp[i+1][j-1]->dp[i][j]属于从左下到右上，递推前必须保证已经被计算过。
本题双指针法空间复杂度更优，注意需要考虑奇数和偶数回文串两种情况。
注意需要从头开始从而包含所有情况，而不是从数组中间开始。（e.g. aabcdef）
```
class Solution {
public:
    int countSubstrings(string s) {
        int result = 0;
        for (int i = 0; i < s.size(); i++) {
            result += extend(s, i, i, s.size()); // 以i为中心
            result += extend(s, i, i + 1, s.size()); // 以i和i+1为中心
        }
        return result;
    }
    int extend(const string& s, int i, int j, int n) {
        int res = 0;
        while (i >= 0 && j < n && s[i] == s[j]) {
            i--;
            j++;
            res++;
        }
        return res;
    }
};
```

## Leetcode 516 最长回文子序列(反复练习)
dp[i][j]：字符串s在[i, j]范围内最长的回文子序列的长度为dp[i][j](i<j)。
递推公式： 
如果s[i]与s[j]不相同，说明s[i]和s[j]的同时加入 并不能增加[i,j]区间回文子序列的长度，那么分别加入s[i]、s[j]看看哪一个可以组成最长的回文子序列。
```
if (s[i] == s[j]) {
    dp[i][j] = dp[i + 1][j - 1] + 2;
} else {
    dp[i][j] = max(dp[i + 1][j], dp[i][j - 1]);
}
```
初始化：将单个元素初始为1！属于本题的基底（一个元素肯定是回文序列且长度为1），递推公式由一个元素扩展而来，如果不初始化会出错（非法位置为0，+2之后为2，实际应为1）.  
遍历顺序：和上题相同，从下往上，从左往右。









