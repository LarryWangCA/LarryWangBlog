---
layout: post
title: "个人代码训练营Day60-Blind75ExtraDay02"
date: 2025-12-19 10:00:00 -0400
categories: 随笔
tags: [heap]
---

# C++ linked list Tips
新增node时，先让新节点认清前后，再让前后节点接纳新节点。  


## Leetcode 23. Merge k Sorted Lists (反复练习) - linked list
直接使用暴力解法，将所有node的值保存到vector中后排序，然后构建一个新的链表。  

## Leetcode 146. LRU Cache (好题,反复练习) - doubly linked list + unordered_map
实现一个 LRU Cache，支持：
	•	get(key)
	•	put(key, value)  
并满足：
	•	时间复杂度：O(1)
	•	容量满时，淘汰「最久未使用」的元素  
两者 缺一不可：  
	•	只有 map → 不知道谁最旧
	•	只有链表 → 查找是 O(n)  
4️⃣ 为什么一定是「双向」链表？  
LRU 需要 O(1) 删除任意节点，包括：
	•	中间节点（get / put 后移动）
	•	尾部节点（淘汰 LRU）
单向链表无法 O(1) 删除已知节点（找不到 prev），
双向链表可以通过 prev / next 直接删除。  
```
struct Node {
    int key;
    int value;
    Node* prev;
    Node* next;
};
```
Node 结构为什么要存 key？LRU 的删除是基于链表位置发生的，而 map 的删除需要 key。  
淘汰时拿到的是：Node* lru = tail->prev;  
	•	此时你只有 Node*，没有 key
	•	如果 Node 不存 key：
	•	❌ 无法 O(1) 从 map 中 erase
	•	❌ 只能遍历 map（O(n)，不合格）  
struct 放哪？
	•	刷题 / 面试：放 class 内（封装）
	•	工程 / 复用：放外部



