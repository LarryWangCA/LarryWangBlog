---
layout: post
title: "代码训练营Day25-贪心03"
date: 2025-10-20 10:00:00 -0400
categories: 随笔
---

# c++ tips
1)
   容器类型	迭代器类型	是否支持 +n 操作	底层结构
vector, deque, array	Random Access Iterator	✅ 支持	连续内存
list, forward_list	Bidirectional / Forward Iterator	❌ 不支持	

容器	能否用 begin() + n	插入效率	适合场景
vector	✅	慢（O(n插入， O(1)查找)）	随机访问
list	❌	快（O(1) 插入，O(n) 查找）	频繁插入删除
deque	✅（部分）	中等	队列结构
2）
sort()中的自定义cmp函数，比较的是输入数组的每个元素
cmp 的参数类型，必须与容器元素类型一致。
vector<int> → 参数是 int
vector<vector<int>> → 参数是 vector<int>



## Leetcode 134 加油站（不好理解，二刷精进）
暴力解法为两层循环嵌套O(N^2)，一个固定开始位置，一个用于判断能否以该起点开一圈
```
        for (int i = 0; i < cost.size(); i++) {
            int rest = gas[i] - cost[i]; // 记录剩余油量
            int index = (i + 1) % cost.size();
            while (rest > 0 && index != i) { // 模拟以i为起点行驶一圈（如果有rest==0，那么答案就不唯一了）
                rest += gas[index] - cost[index];
                index = (index + 1) % cost.size();
            }
            // 如果以i为起点跑一圈，剩余油量>=0，返回该起始位置
            if (rest >= 0 && index == i) return i;
        }
        return -1;
    }
```
贪心思路：总加油量>总消耗一定可以跑完一圈。
从任意起点出发，规则是“到站先加油，再开到下站”。如果你能完整地绕一圈回到起点，油箱最终的油量（从 0 开始记账）就等于把这一圈所有的 diff[i] 都加一遍的结果，也就是 totalSum。
若 totalSum < 0，那意味着就算你把这一圈所有站的油都拿了，也不够付这一圈的路费。更强地说：你即便走到了最后一个站，把该站油加上后再开回起点，最后账面仍是负的（= totalSum），因此不可能完成闭环。
所以 totalSum < 0 时一定无解。
确保curSum>0即可（等于0时就不是唯一解）
* 重点：curSum<0时，从i+1开始设置为起点
* 为啥i+1之前不会有解？
如果 curSum<0 说明 区间和1 + 区间和2 < 0， 那么 假设从上图中的位置开始计数curSum不会小于0的话，就是 区间和2>0。
区间和1 + 区间和2 < 0 同时 区间和2>0，只能说明区间和1 < 0， 那么就会从假设的箭头初就开始从新选择起始位置了.

## Leetcode 135 分发糖果(反复练习)
利用分数的单调性，从左向右遍历时只考虑右孩子比左孩子高的情况，从右向左遍历时只考虑左孩子比右孩子高的情况（和从左向右的结果取最大值）
注意糖果数量是和在孩子的数量上增加，不是自增。
两个维度，先固定一边，再考虑另一边。

## Leetcode 860 柠檬水找零
记录各种钱的数量，贪心思路：优先消耗10美元找零钱，因为5美元更万能。

## Leetcode 406 根据身高重构队列(反复练习)
本题有身高和顺序两个维度，需要将身高从高到低排列，相同时顺序小的在前面（先固定一个维度）。
无法用顺序从小到大排列，因为后序身高的变化会打乱顺序，造成两个维度都没法确定。
遍历排序后的数组，根据维度插入（答案数组）对应位置即可。




