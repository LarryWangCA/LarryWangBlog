---
layout: post
title: "代码训练营Day31-动态规划04"
date: 2025-10-27 10:00:00 -0400
categories: 随笔
tags: [dp]
---

## Leetcode 1049 最后一块石头的重量 II(反复练习)
dp数组含义：dp[j]表示容量（这里说容量更形象，其实就是重量）为j的背包，最多可以背最大重量为dp[j]。   
递推公式：dp[j] = max(dp[j], dp[j - stones[i]] + stones[i])。   
dp数组初始化：全为0即可。    
遍历顺序：与01背包相同。   

必须等for循环结束才是考虑了所有情况的dp数组：
每一轮物品循环都会更新 dp，
dp[j] 在第一轮只考虑了前1个石头的组合，第二轮才有“前2个石头的组合”，第三轮才是“前3个石头的组合”。
👉 所以必须等所有外层循环结束后，dp[target] 才是“所有石头都考虑过”的最终状态。
在前两轮中，dp[target] 只考虑了一部分石头的可能组合

## Leetcode 494 目标和（反复练习）
加法集合+减法集合=sum；
加法集合-减法集合=target；
加法集合=（target+sum）/2;
本题可以转化为，装满加法集合这个背包，一共有多少种方法。
先使用二维数组进行理解：
dp[i][j]：使用 下标为[0, i]的nums[i]能够凑满j（包括j）这么大容量的包，有dp[i][j]种方法。
递推公式：
不放物品i：即背包容量为j，里面不放物品i，装满有dp[i - 1][j]中方法。
放物品i： 即：先空出物品i的容量，背包容量为（j - 物品i容量），放满背包有 dp[i - 1][j - 物品i容量] 种方法。
本题中，物品i的容量是nums[i]，价值也是nums[i]。
递推公式：dp[i][j] = dp[i - 1][j] + dp[i - 1][j - nums[i]];
考到这个递推公式，我们应该注意到，j - nums[i] 作为数组下标，如果 j - nums[i] 小于零呢？
说明背包容量装不下 物品i，所以此时装满背包的方法值 等于 不放物品i的装满背包的方法，即：dp[i][j] = dp[i - 1][j];
```
if (nums[i] > j) dp[i][j] = dp[i - 1][j]; 
else dp[i][j] = dp[i - 1][j] + dp[i - 1][j - nums[i]];
```
初始化：需要初始化第一行和第一列，注意元素的容量可以为0，所以背包重量为0时，方法数与容量为0的元素个数有关！
```
        // 初始化最上行
        if (nums[0] <= bagSize) dp[0][nums[0]] = 1; 

        // 初始化最左列，最左列其他数值在递推公式中就完成了赋值
        dp[0][0] = 1; 

        int numZero = 0;
        for (int i = 0; i < nums.size(); i++) {
            if (nums[i] == 0) numZero++;
            dp[i][0] = (int) pow(2.0, numZero);
        }
```
一维化dp方案：
dp数组含义：填满j（包括j）这么大容积的包，有dp[j]种方法。
递推公式：dp[j] += dp[j - nums[i]] （常用于求方法数）
初始化：dp[0]=1,理解为二维数组的-1行，空集方案，啥都不放。
遍历顺序：与二维01背包相同。

## Leetcode 474 一和零（反复练习）
本题中strs 数组里的元素就是物品，每个物品都是一个！
而m 和 n相当于是一个背包，两个维度的背包。
理解为每个数组的重量有两个维度：0的个数和1的个数；价值为1（每个字符串自身个数即为价值）
dp[i][j]：最多有i个0和j个1的strs的最大子集的大小为dp[i][j]
递推公式：dp[i][j] = max(dp[i][j], dp[i - zeroNum][j - oneNum] + 1);
初始化：初始化为0，因为不会有空数组
遍历顺序；与一维dp相同，只是遍历到背包时，依然是for循环嵌套（有两个维度，容量大小先基于0的个数还是1的个数都行）







