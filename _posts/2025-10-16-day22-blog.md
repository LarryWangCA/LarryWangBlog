---
layout: post
title: "代码训练营Day22-回溯04"
date: 2025-10-16 10:00:00 -0400
categories: 随笔
---

区分使用used数组去重和unordered_set()去重

| 维度 | used 数组（配合排序 + `used[i-1] == false`） | 每层 `set` |
|---|---|---|
| 思想 | 区分“同层 vs 同枝” | 只管“同层是否出现过该值” |
| 是否要排序 | ✅ 通常要排序 | ✅ 一般也排序（让重复值相邻更稳定） |
| 需要回溯什么 | `path` + `used[i]` | 只回溯 `path`；`set` 是本层局部变量，出栈自动丢弃 |
| 代码复杂度 | 稍复杂（判重条件易混淆） | 更直观（本层见过就跳） |
| 适用 | 子集/组合/排列等都可；**排列问题（如 LC47）常用它** | 子集/组合很香；**排列问题不够用**（排列需要更精细的“同枝/同层”区分） |
| 易错点 | 忘记回溯 `used`，或判重条件写错 | 一般不易错，但注意 `set` 的额外开销（可用布尔数组代替） |






## Leetcode 491 递增子序列
和之前子集的区别，本题的输入集合不能排序，因为答案需要保持原有的顺序。


