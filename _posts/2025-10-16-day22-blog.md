---
layout: post
title: "代码训练营Day22-回溯04"
date: 2025-10-16 10:00:00 -0400
categories: 随笔
---

区分使用used数组去重和unordered_set()去重；
used数组是一个全局变量，随着path变化，必须回溯，且输入数组必须，与前值的判断一起进行去重。
set在backtracking函数内，for循环外，每层会重新初始化，适合树层去重，开销稍大，可单独使用。
set只适合同层去重！（其中无法排序时，used数组法不好用，此时只能用set法去重，如LC491）
| 维度 | used 数组（配合排序 + `used[i-1] == false`） | 每层 `set` |
|---|---|---|
| 思想 | 区分“同层 vs 同枝” | 只管“同层是否出现过该值” |
| 是否要排序 | ✅ 通常要排序 | ✅ 一般也排序（让重复值相邻更稳定） |
| 需要回溯什么 | `path` + `used[i]` | 只回溯 `path`；`set` 是本层局部变量，出栈自动丢弃 |
| 代码复杂度 | 稍复杂（判重条件易混淆） | 更直观（本层见过就跳） |
| 适用 | 子集/组合/排列等都可；**排列问题（如 LC47）常用它** | 子集/组合很香；**排列问题不够用（如LC491）**（排列需要更精细的“同枝/同层”区分） |
| 易错点 | 忘记回溯 `used`，或判重条件写错 | 一般不易错，但注意 `set` 的额外开销（可用布尔数组代替） |


## Leetcode 491 递增子序列（反复练习）
和之前子集的区别，本题的输入集合不能排序，因为答案需要保持原有的顺序。
所以不能用used数组去重，因为used数组输入需要排序，结合前值判断。
path和used数组相同，是成员变量，反应从根到节点的变化；而set数组是函数里局部变量，只约束本层；所以两者看起来在回调函数内位置相同，但是范围不同。

## Leetcode 46 全排列(反复练习)
理解排列和组合的区别，组合不考虑顺序（从左到右挑选即可），排列不同顺序是不同结果（每一层都能从剩余任意位置挑一个放到当前位置）。
所以不需要startIndex的逻辑，每次都要结合used数组从输入数组的开头进行判断（树枝去重！防止同一个元素被重复使用）
结果都在叶子节点上。

## Leetcode 47 全排列II（反复练习）
在上题的基础上加上排序和树层去重即可，即本题需要树枝去重和树层去重（使用used数组实现）！
而set只能实现同层去重！所以不能使用set（同理46也不行）

## Leetcode 52 N皇后（没写，看了思路，二刷时精进）
本质上也是个递归，树的宽度为棋盘的宽度（不同列），树的深度为棋盘的深度（不同行）。
将当前的棋盘递归到下一层判断，直到到了最后一层。如果此时仍然符合条件，则为一种符合条件的棋盘布局。
🟦 N皇后：每行 1 皇后 → 每层对应 1 行 → 一维递归

## Leetcode 37 解数独（没写，看了思路，二刷时精进，二维递归！）
每一格是一个递归，需要用两个for循环嵌套，外层控制行，内层控制列。
每一个格子是一层递归，填充完成后再去填下一个，一行填完后再去下一行，直到找到一个符合条件的结果。
🟨 数独：每格 1 数字 → 每层对应 1 格 → 二维递归




