---
layout: post
title: "代码训练营Day10-栈与队列02"
date: 2025-09-28 10:00:00 -0400
categories: 随笔
---
C++基础知识：sort只能对random access iterator(可以连续访问，时间为O(1))进行排序，常用的即为array, vector, deque, srting。  
list, map, priority_queue(stack和queue也不行，外部看不到其deque的接口)的内部不连续，无法使用sort。  

## Leetcode 150 逆波兰表达式求值
stack的应用，逆波兰表达式为后续遍历，需注意先pop的为num2,后pop的为num1，需要num1运算符num2。  
单个字符可以用"7"-"0"将字符转换为int，字符串则需要使用函数stoi()或者stoll()。

## Leetcode 239 滑动窗口最大值(单调队列的使用，需要反复练习)
直接的暴力解法如下，会超时 O(nums.size()*k)
```
vector<int> maxSlidingWindow(vector<int>& nums, int k) {
    vector<int> ans;
    for (int i = 0; i + k <= nums.size(); i++) {
        int mx = INT_MIN;
        for (int j = i; j < i + k; j++) {
            mx = max(mx, nums[j]);
        }
        ans.push_back(mx);
    }
    return ans;
}
```
通过deque实现单调最列（两端均可push和pop!）本题队列front为最大值，之后单调递减,实现以下class
```
pop:        // 每次弹出的时候，比较当前要弹出的数值是否等于队列出口元素的数值，如果相等则弹出。  
            // 同时pop之前判断队列当前是否为空。
push:       // 如果push的数值大于入口元素的数值，那么就将队列后端的数值弹出，直到push的数值小于等于队列入口元素的数值为止。
            // 这样就保持了队列里的数值是单调从大到小的了。
front:      // 查询当前队列里的最大值 直接返回队列前端也就是front就可以了。
```
之后遍历整个数组执行pop，push, front即可。

## Leetcode 347 前K个高频元素
最直接的思路，用unordered_map<int,int>统计各数出现频率，从大到小排序，输出即可。
有两点需要注意，1) umordered_map本身不可直接sort，需要转换为vector<int> pair。
2）sort是需要使用lambda表达式（或者自创cmp函数），默认情况下是对第一个元素从小到大升序排列
```
    // 根据出现次数排序（从大到小）
    sort(vec.begin(), vec.end(), [](auto &a, auto &b){
        return a.second > b.second;
    });
```
上述直接法为 O(nlogn).


小顶堆法每次只比较k个元素，目前了解即可。O(nlogk)
```
priority_queue	vector (默认) + 堆算法。  
按优先级排序 (最大/最小堆),与插入顺序无关。  
push() pop() top()	取最大值/最小值的场景。  
// 默认是大顶堆（最大值在 top）
priority_queue<int> pq1;

// 小顶堆（最小值在 top）
priority_queue<int, vector<int>, greater<int>> pq2;
```



