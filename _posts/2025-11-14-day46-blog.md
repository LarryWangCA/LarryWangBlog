---
layout: post
title: "代码训练营Day46-图论04"
date: 2025-11-14 10:00:00 -0400
categories: 随笔
---

# C++ Tips
queue需要使用pair？是的，因为默认只有一个元素，超过一个时需要用pair包装。  

list是双向链表，大部分链表类题目并不需要使用list。
自己实现时，使用struct和指针实现即可。
```
struct ListNode {
    int val;
    ListNode* next;
    ListNode(int x) : val(x), next(nullptr) {}
};
```
vector<vector<int>> graph(n+1) //领接表的创建，外层知道大小，内层不知道。
    •	创建一个长度为 n + 1 的外层 vector，
	•	其中的每个元素 都是一个空的 vector<int>。


## 卡码网 110 字符串接龙 （反复练习）
本题思路：对于无权图，bfs广搜替换一个字母后的各种组合，得到的路径即为最短路径。（深搜还需额外判断得到的各种路径）  
需要一个set来判断是否是用于连接的字符串。  
需要一个map来判断是否重复使用过，并且记录当前的步数，之后的新词在该词的步数+1。  

## 卡码网 105 有向图的完全联通 (反复练习)
邻接矩阵写法（参考卡码网所有可达路径）：  
领接表写法（本题,方便知道一个节点所连接的所有节点）：  
有两种写法：图不变，只遍历：推荐用vector<vector<int>> （随机访问时O(1)）； 
需要频繁加/删边：vector<list<int>> （随机访问是O(N),但是插入和删除节点是O(1)）。
本题不需要删改，使用vector<vector<int>>构造graph更高效,输入时基于边的数量而不是节点数量！
```
    int n, m;
    cin >> n >> m;

    vector<vector<int>> graph(n + 1);
    for (int i = 0; i < m; i++) {
        int s, t;
        cin >> s >> t;
        graph[s].push_back(t);
    }
```

## 卡码网 106 岛屿的周长
本题需要避免惯性思维，其实很简单，用领接矩阵存graph,不需要dfs或者bfs,直接遍历即可。
到达每个陆地时，判断其上下左右四个节点的情况，如果是水或者地图边界，周长就++。









