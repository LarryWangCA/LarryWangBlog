---
layout: post
title: "代码训练营Day38-动态规划11"
date: 2025-11-04 10:00:00 -0400
categories: 随笔
tags: [dp]
---

## Leetcode 1143 最长公共子序列
与上题相同，子序列问题dp数组经常定义到i-1，j-1，初始化更方便。
dp[i][j]：长度为[0, i - 1]的字符串text1与长度为[0, j - 1]的字符串text2的最长公共子序列为dp[i][j]。
递推公式：如果text1[i - 1] 与 text2[j - 1]相同，那么找到了一个公共元素，所以dp[i][j] = dp[i - 1][j - 1] + 1;
如果text1[i - 1] 与 text2[j - 1]不相同，那就看看text1[0, i - 2]与text2[0, j - 1]的最长公共子序列 和 text1[0, i - 1]与text2[0, j - 2]的最长公共子序列，取最大的。
初始化：text1[0, i-1]和空串的最长公共子序列自然是0，所以dp[i][0] = 0。同理dp[0][j]也是0。
遍历顺序：从左向右。
Time and Space: O(mn).

## Leetcode 1035 不相交的线
本题本质上与上题相同，理解为最长公共子序列即可。

## Leetcode 53 最大子序和
本题可以用贪心解法，dp解法也很直接。
dp[i]：包括下标i（以nums[i]为结尾）的最大连续子序列和为dp[i]。
递推公式：
dp[i - 1] + nums[i]，即：nums[i]加入当前连续子序列和
nums[i]，即：从头开始计算当前连续子序列和
一定是取最大的，所以dp[i] = max(dp[i - 1] + nums[i], nums[i])
初始化：dp[0] = nums[0].
遍历顺序：从左向右。

## Leetcode 392 判断子序列
本题用双指针法比较简单：
```
    bool isSubsequence(string s, string t) {
        int i = 0, j = 0;
        while (i < size(s) && j < size(t))
        {
            if (s[i] == t[j])
            {
                i++;
            }
            j++;
        }
        return i==size(s)? true: false;
    }
```
动态规划的解法更有模版性（非常类似于求最长公共子序列）：
dp[i][j]：长度为[0, i - 1]的字符串text1与长度为[0, j - 1]的字符串text2的最长公共子序列为dp[i][j]。
递推公式：如果text1[i - 1] 与 text2[j - 1]相同，那么找到了一个公共元素，所以dp[i][j] = dp[i - 1][j - 1] + 1;
如果text1[i - 1] 与 text2[j - 1]不相同，那就看看text1[0, i - 1]与text2[0, j - 2]的最长公共子序列（本题只要看s属不属于t）。
初始化：text1[0, i-1]和空串的最长公共子序列自然是0，所以dp[i][0] = 0。同理dp[0][j]也是0。
遍历顺序：从左向右。













