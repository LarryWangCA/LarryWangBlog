---
layout: post
title: "代码训练营Day39-动态规划12"
date: 2025-11-05 10:00:00 -0400
categories: 随笔
tags: [dp]
---

## Leetcode 115 不同的子序列(反复练习)
本题可以直接理解为求s中有多少个t。
dp[i][j]：以i-1为结尾的s子序列中出现以j-1为结尾的t的个数为dp[i][j]。
	•	如果问题里有两个序列要同时推进匹配 → 需要两个维度 (i,j)。
	•	j 不是多余的，它表示“t 匹配到哪里了”，这是递推必须知道的状态。
递推公式：
当s[i-1] == t[j-1]
dp[i][j] = dp[i-1][j-1] （选）+ dp[i-1][j] （不选）
可以选，也可以不选，方案数相加
当s[i-1] != t[j-1]
dp[i][j] = dp[i-1][j]
当前字符无用，只能跳过
具体解释：
e.g. s=babg, t=bag
✅ 情况 1：选用这个 ‘g’ 来匹配

那我们就把这个 ‘g’ 加入匹配对中。
	•	那么在这之前，s 的前 3 个字符 "bab" 必须已经能组成 t 的前 2 个字符 "ba"。
	•	所以这种“选择”的数量就是：dp[i-1][j-1] = dp[3][2]。

也就是说：“如果我选这个 ‘g’ 来配 t 的 ‘g’，那前面必须已经有办法把 'ba' 组成出来。”

🚫 情况 2：不选这个 ‘g’

我也可以选择跳过当前这个 s[i-1]，
那我就让更短的 s 去匹配同样长度的 t。
	•	也就是只用 "bab"（前 3 个字符）来组成 "bag"（整个 t）。
	•	这部分方案数是 dp[i-1][j] = dp[3][3]。

也就是说：“我不选当前这个 ‘g’，看看前面的 'bab' 能不能自己完成匹配。”
初始化：dp[i][0]=1,任意长度的s中都有一个空字符串。
遍历顺序：从左往右。

本题与求长度问题的区别：
1143 最长公共子序列：求最长长度
dp[i][j] = dp[i-1][j-1] + 1
相等 → 在前面最长序列基础上 +1
115 不同子序列数：求方案数
dp[i][j] = dp[i-1][j-1] + dp[i-1][j]
相等 → 可以选它或不选它，两种方案相加

## Leetcode 583 两个字符串的删除操作(反复练习)
直接dp解法：
dp[i][j]：以i-1为结尾的字符串word1，和以j-1位结尾的字符串word2，想要达到相等，所需要删除元素的最少次数。
递推公式：
当word1[i - 1] 与 word2[j - 1]相同的时候，dp[i][j] = dp[i - 1][j - 1]//不需要删除该元素，只考虑之前的次数;
当word1[i - 1] 与 word2[j - 1]不相同的时候，考虑三种删除情况，删一个或者都删
dp[i][j] = min({dp[i - 1][j - 1] + 2, dp[i - 1][j] + 1, dp[i][j - 1] + 1});
初始化：
dp[i][0]：word2为空字符串，以i-1为结尾的字符串word1要删除多少个元素，才能和word2相同呢，很明显dp[i][0] = i。
dp[0][j]的话同理。
字符串类问题所有位置均可达，所以可以设置为任意值。但是背包问题有些状态不可达，初始化时需要特别注意（-1, INT_MIN, INT_MAX）！
遍历顺序：从左向右。
间接dp解法：
转化为求最长公共子序列，ans=word1.size()+word2.size()-dpNew[word1.size()][word2.size()]*2;

## Leetcode 72 编辑距离（经典问题！反复练习）
a变成b和b变成a的次数相同！（a的插入等同于b的删除）。
dp[i][j] 表示以下标i-1为结尾的字符串word1，和以下标j-1为结尾的字符串word2，最近编辑距离为dp[i][j]。
递推公式：
相等时不需要任何编辑，
不相等时需要考虑以下三种操作最小值：
dp[i-1][j] + 1：把 word1 少一个字符，删除 word1[i-1]。（e.g. ab vs a）
dp[i][j-1] + 1：把 word2 少一个字符，插入 word2[j-1] 到 word1。(e.g. a vs ab)
dp[i-1][j-1] + 1：(e.g. ab vs ac)
都少一个字符，替换 word1[i-1] → word2[j-1]。
初始化：与上题相同：
dp[i][0] ：以下标i-1为结尾的字符串word1，和空字符串word2，最近编辑距离为dp[i][0]。
那么dp[i][0]就应该是i，对word1里的元素全部做删除操作，即：dp[i][0] = i;
同理dp[0][j] = j。
遍历顺序，从左到右。






