---
layout: post
title: "代码训练营Day34-动态规划07"
date: 2025-10-30 10:00:00 -0400
categories: 随笔
tags: [dp]
---

## Leetcode 198 打家劫舍（反复练习）
dp[i]：考虑下标i（包括i）以内的房屋，最多可以偷窃的金额为dp[i]。
递推公式：
如果偷第i房间，那么dp[i] = dp[i - 2] + nums[i] ，即：第i-1房一定是不考虑的，找出 下标i-2（包括i-2）以内的房屋，最多可以偷窃的金额为dp[i-2] 加上第i房间偷到的钱。
如果不偷第i房间，那么dp[i] = dp[i - 1]，即考 虑i-1房，（注意这里是考虑，并不是一定要偷i-1房，这是很多同学容易混淆的点）
然后dp[i]取最大值，即dp[i] = max(dp[i - 2] + nums[i], dp[i - 1]);
初始化：
dp[0]=nums[0], dp[1]=max(nums[0], nums[1]),其余为0即可
遍历顺序：从左到右。
因为初始化需要dp[0]和dp[1],所以nums.size()<=2的情况需要单独返回（edge case）。

## Leetcode 213 打家劫舍 II
环形连接，实际上和上题相比，只是有了两种情况需要考虑。
1）考虑nums[0] to nums[length-2].//不包含末尾
2) 考虑nums[1] to nums[length-1].//不包含开头
两种情况取最大值即可。

## Leetcode 337 打家劫舍 III(反复练习，二叉树和dp结合的好题)
Notes:
树形DP永远是“后序遍历”思维：
因为父节点的最优状态依赖于子节点的状态，
所以必须“先处理子树，再处理根”。
本题需要在后序遍历从下到上处理，最终在根节点处判断（类似于之前的监控二叉树）。
本题dp数组大小为2，为每个节点不偷或者偷所获得的最大金额。
在中节点处处理，返回该节点偷或者不偷的最大金额（根据左右孩子判断）。








