---
layout: post
title: "代码训练营Day20-回溯02"
date: 2025-10-14 10:00:00 -0400
categories: 随笔
tags: [backtracking]
---
# Tips：
std::string s = "abcdef";
std::string t1 = s.substr(pos);        // 从 pos 到结尾
std::string t2 = s.substr(pos, count); // 从 pos 开始取 count 个字符
索引从0开始，pos, count其实是size_t, 但是大部分情况下int型也能用。

剪枝/终止条件相关：
return：这层递归整体结束（纵向截断），不再看本层任何候选(常用于终止条件，收获结果处)。
break：只结束本层 for 的后续兄弟（横向剪枝），然后函数才返回上一层。
continue：跳过当前候选，继续本层下一个候选（横向跳过）。


## Leetcode 39 组合总和
本题同一个元素可以重复选，所以终止条件不能通过个数判断，而是通过sum是否等于或者超过target。
在递归时startIndex不用加一，因为同一个元素可以重复选。
剪枝时需要将输入的数组从小到大排序。

## Leetcode 40 组合总和III (反复练习)
本题与之前不同，输入的组合中有重复元素。
本题需要做到树层去重，而不是树枝去重。
同一个元素在树枝中可以重复（如果在输入输入中有重复的话），在同一树层不能重复，因为第一次出现时就已经包含了所有情况。
我们需要使用used数组以及和之前的值是否相同进行判断（输入数组需要从小到大排序）。

## Leetcode 131 分割回文串（反复练习）
分割问题本质上也是排列问题。结合昨天的图，需要理解[startIndex, i]这个区间是每个子串的范围。
本题终止条件为startIndex到达最后（这种方法比较方便），判断是否为回文串在for循环中进行（类似于之前的剪枝）。



